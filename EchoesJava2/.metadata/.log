!SESSION 2012-05-06 13:30:01.515 -----------------------------------------------
eclipse.buildId=M20110909-1335
java.version=1.7.0
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86_64

This is a continuation of log file C:\Keith\echoes\EchoesJava\.metadata\.bak_7.log
Created Time: 2012-05-06 15:25:50.695

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:50.697
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:50.699
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:54.192
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void EchoesGLCanvas(parent)
  {
      
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:54.196
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:54.198
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:54.323
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void EchoesGLCanvas(parent)
  {
      
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:54.326
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:54.328
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:57.241
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void EchoesGLCanvas(parent)
  {
      
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:57.244
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:57.246
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 17:39:31.597
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
## @package interface.RenderingEngineImpl
# Implementation of the rendering engine interface
# @authors Chris, Mef
import Ice
import Logger
import echoes
import objects.Bubbles
import objects.Plants
import agents.PiavcaAvatars
import environment.Backgrounds
import environment.HelperElements
import environment.Menu
import objects.Environment
import visual.Annotator
from visual.EchoesGLCanvas import CreatePiavcaAvatar, LoadScenario, EndScenario, AddObject, SetObjectProperty, RemoveObject, StartAnnotator, StopAnnotator, AnnotatorDrawing, AnnotatorNoDrawing
import wx
import math

## Implementation of the rendering engine interface called from other modules via ICE 
#
#    
public class RenderingEngineImpl(echoes.RenderingEngine)
    ## 
    #
    public void __init__(rlPublisher)
        ## Reference to the main application.
        this.app = app
        ## The publisher to publish events to rendering engine listeners.
        this.rlPublisher = rlPublisher
        ## Counter of unique action ids.
        this.unique_actionid = 0
        ## Record of action ids currently being processed.
        this.currentActions = dict()

    ## Loading scenarios by name
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas 
    public void loadScenario_async(_cb, name, current=None)
        Logger.trace("info", "loadScenario " + name)
        
        evt = LoadScenario(name=name, callback=_cb)
        wx.PostEvent(this.app.canvas, evt)
        
    ## Ending scenarios by name
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas             
    public void endScenario_async(_cb, name, current=None)
        Logger.trace("info", "endScenario " + name)
        
        evt = EndScenario(name=name, callback=_cb)
        wx.PostEvent(this.app.canvas, evt)

    ## Set a property of the world
    # @param propName Name of the property to be set as string
    # @param propValue Value of the property as string
    #
    # Available properties are
    # - \b UserList set the user list for the intro screen (space separated string of names)
    # - \b numBubbles number of bubbles in the scene 
    # - \b DisplayScore display a score (true/false)
    # - \b SetScore set the score (integer)
    # - \b IncrementScore increment the score
    # - \b LightLevel setting the light level of the scene (0 to 1)
    # - \b Annotator show the Annotator overlay (true/false)
    # - \b AnnotatorDrawing enable drawing on the Annotator overlay (true/false)
    public void setWorldProperty(propName, propValue, current=None)
        Logger.trace("info", "setWorldProperty " + propName + " " + propValue)

        if ("Score" in propName
            bs = None
            for id, object in this.app.canvas.sceneElements.items()
                if (isinstance(object, environment.HelperElements.Score)
                    bs = object
                    break

        if ((propName == "UserList")
            this.app.canvas.userList = propValue.split(' ')

        else if ((propName == "numBubbles")
            targetNum = int(propValue)
            curBubbles = [] 
            for id,object in this.app.canvas.objects.items()
                if (isinstance(object, objects.Bubbles.EchoesBubble)
                    curBubbles.append(object)
            if ((len(curBubbles) < targetNum)
                for i in range (0, targetNum - len(curBubbles))
                    evt = AddObject(type="Bubble", callback=None)
                    wx.PostEvent(this.app.canvas, evt)
            else
                while (len(curBubbles) > targetNum)
                    curBubbles.pop().remove()

        else if (propName == "DisplayScore"
            if (propValue == "false" and bs != None
                bs.remove()
            if (propValue == "true" and bs == None
                environment.HelperElements.Score(this.app)
                
        else if (propName == "SetScore" and bs
            bs.setScore(int(propValue))

        else if (propName == "IncrementScore" and bs
            bs.increment()

        else if (propName == "LightLevel"
            this.app.canvas.targetLightLevel = float(propValue) 
                
        else if (propName == "Annotator"
            if (propValue == "true" 
                evt = StartAnnotator()
            else
                evt = StopAnnotator()    
            wx.PostEvent(this.app.canvas, evt)
        else if (propName == "AnnotatorDrawing"
            if (propValue == "true" 
                evt = AnnotatorDrawing()
            else
                evt = AnnotatorNoDrawing()    
            wx.PostEvent(this.app.canvas, evt)

    ## Add an agent with a certain pose
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                             
    public void addAgentWithPose_async(_cb, agentType, pose, current=None)
        Logger.trace("info", "addAgentWithPose " + agentType)
        if (agentType == "Paul"
            # this needs to be done via wx.Events because the ICE callbacks reside in a different thread    
            evt = CreatePiavcaAvatar(type="Paul", autoadd=true, pose=pose, callback=_cb)
            wx.PostEvent(this.app.canvas, evt)
        else
            this.addAgent_async(_cb, agentType, current)

    ## Add an agent to the scene
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                         
    public void addAgent_async(_cb, agentType, current=None)
        Logger.trace("info", "addAgent " + agentType)
        if (agentType == "Paul"        
            # this needs to be done via wx.Events because the ICE callbacks reside in a different thread    
            evt = CreatePiavcaAvatar(type="Paul", autoadd=true, callback=_cb)
            wx.PostEvent(this.app.canvas, evt)
        else if (agentType == "Andy"        
            # this needs to be done via wx.Events because the ICE callbacks reside in a different thread    
            evt = CreatePiavcaAvatar(type="Andy", autoadd=true, callback=_cb)
            wx.PostEvent(this.app.canvas, evt)
        else
            Logger.warning("Cannot create agent of type " + agentType)
            _cb.ice_response("")

    ## Remove an agent from the scene
    #
    public void removeAgent(agentId, current=None)
        this.app.canvas.agents[int(agentId)].remove() 

    ## Call on an agent to execute an action 
    # @param agentId the id of the agent that is called upon
    # @param action the action the agent is asked to perform as string
    # @param details details for the action as a list of strings 
    # @return Boolean whether the action has been started successfully or failed (e.g., if (certain preconditions are not fulfilled)
    #
    # The following \b actions and their corresponding details (in brackets, optional details in \e italic) are available
    # - \b LookAtPoint [x, y, z, \e "speech1.wav,speech2.wav", \e "speed=1.0", \e "hold=0.0"] \b Note All speech is optional and synchronised with gestures or movements, \e speed is a timefactor for the motion and \e hold determines how long the agent holds the gesture before moving on
    # - \b LookAtObject [objectId, \e"speech1.wav,speech2.wav", \e "speed=1.0", \e "hold=0.0"]
    # - \b LookAtChild [\e "speech1.wav,speech2.wav", \e "speed=1.0", \e "hold=0.0"]
    # - \b PointAt [objectId, \e "speed=1.0", \e "hold=0.0"]
    # - \b PointAtPoint [x, y, z, \e "speed=1.0", \e "hold=0.0"]
    # - \b TurnTo [objectId]
    # - \b TurnToPoint [x, z]
    # - \b TurnToChild []
    # - \b SetPosition[x,z]    \b Note instant relocation of the agent
    # - \b SetDepthLayer["front"/"back"]    \b Note instant relocation and scaling of the agent to appear in the back
    # - \b WalkTo [x, z]
    # - \b WalkToObject [objectId]
    # - \b ResetPosture []
    # - \b Gesture [gesture, \e "x,z", \e "speech1.wav,speech2.wav", \e "speed=1.0", \e "hold=0.0"] \b Note second argument is optional orientation after gesture       
    # - \b TouchObject [objectId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"] \b Note the WalkTo flag causes the agent to walk to the object before performing the action
    # - \b PickFlower ([flowerId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"]
    # - \b PutFlowerDown ["WalkTo=0-9"] \b Note 0-9 indicate vertical slots in the scene from left to right
    # - \b PutFlowerInPot [\e potId] \b Note optional object ids cause the agent to use any suitable object in the scene
    # - \b PutFlowerInBasket[\e basketId, \e "WalkTo=true"]
    # - \b TouchFlower [\e flowerId, \e "speech1.wav,speech2.wav"]
    # - \b TouchFlower-Bubble [\e flowerId, \e "speech1.wav,speech2.wav"]
    # - \b TouchFlower-Ball [\e flowerId, \e "speech1.wav,speech2.wav"]
    # - \b PickUpPot [\e potId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"]
    # - \b PutPotDown [\e "WalkTo=0-9"]
    # - \b StackPot [\e potId, \e "WalkTo=true"]
    # - \b PickUpBasket [\e basketId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"]
    # - \b PutBasketDown ([\e "WalkTo=0-9"]
    # - \b MakeRain [\e cloudId, \e "WalkTo=true"]
    # - \b TouchLeaves [\e leavesId]
    # - \b AttachCloud [\e cloudId]
    # - \b DetachCloud []
    # - \b PopBubble [\e bubbleId]
    # - \b Say ["speech1.wav,speech2.wav"]
    # - \b PickUpBall [\e ballId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"]
    # - \b PutBallDown [\e "WalkTo=0-9"]
    # - \b ThrowBall [\e cloudId] \b Note if (cloudId is given, agent walks to the cloud and the ball is thrown through the cloud 
    # - \b PutBallIntoContainer [\e containerId, \e "WalkTo=true"]
    public void executeAction_async(_cb, agentId, action, details, current=None)
        this.unique_actionid +=1
        orig_details = details[]
        Logger.trace("info", "executeAction " + str(agentId) + " " + str(action) + " " + str(details) + " unique action id " + str(this.unique_actionid))
        try
            agent = this.app.canvas.agents[int(agentId)]
        except KeyError
            Logger.trace("Warning", "No agent with ID " + str(agentId) + " found")
            print str("Here are the available agents " + str(this.app.canvas.agents))
            agent = None    
        if (agent
            speech = None 
            speed = 1.0
            hold = 0.0
            try
                for detail in details
                    if (detail and ".wav" in detail
                        speech = detail
                        del details[details.index(detail)]
                        break
                for detail in details
                    if (detail and "speed" in detail
                        speed = float(detail.split("=")[1])
                        del details[details.index(detail)]
                        break
                for detail in details
                    if (detail and "hold" in detail
                        hold = float(detail.split("=")[1])
                        del details[details.index(detail)]
                        break
            except
                Logger.warning("executeAction was called with details which are not in a list, this might cause problems")
            actionStarted = false
            if (action == "LookAtObject"
                actionStarted = agent.lookAtObject(int(details[0]), speech=speech, speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "LookAtPoint"
                actionStarted = agent.lookAtPoint(float(details[0]), float(details[1]), float(details[2]), speech=speech, speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "LookAtChild"
                actionStarted = agent.lookAtChild(speech=speech, speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "PointAt"
                actionStarted = agent.pointAt(int(details[0]), speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "PointAtPoint"
                actionStarted = agent.pointAtPoint(float(details[0]), float(details[1]), float(details[2]), speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "TurnTo"
                actionStarted = agent.turnTo(int(details[0]), action_id = this.unique_actionid)
            else if (action == "TurnToPoint"
                actionStarted = agent.turnToPoint(float(details[0]), float(details[1]), action_id = this.unique_actionid)
            else if (action == "TurnToChild"
                actionStarted = agent.turnToChild(action_id = this.unique_actionid)
            else if (action == "PopBubble"
                actionStarted = agent.popBubble(int(details[0]), action_id = this.unique_actionid)
            else if (action == "WalkTo"
                actionStarted = agent.walkTo(float(details[0]), float(details[1]), action_id = this.unique_actionid)
            else if (action == "WalkToObject"
                actionStarted = agent.walkToObject(int(details[0]), action_id = this.unique_actionid)
            else if (action == "SetPosition"
                actionStarted = agent.setPosition([float(details[0]), float(details[1])], action_id = this.unique_actionid)
            else if (action == "SetDepthLayer"
                actionStarted = agent.setDepthLayer(details[0], action_id = this.unique_actionid)
            else if (action == "ResetPosture"
                actionStarted = agent.resetPosture(action_id = this.unique_actionid)
            else if (action == "Gesture"
                if (len(details) == 2
                    if (details[1] == "child"
                        actionStarted = agent.gesture(details[0], orientation=["child"], speech = speech, speed = speed, hold = hold, action_id = this.unique_actionid)
                    else
                        x, z = details[1].split(",")
                        actionStarted = agent.gesture(details[0], orientation=(float(x), float(z)), speech = speech, speed = speed, hold = hold, action_id = this.unique_actionid)
                else 
                    actionStarted = agent.gesture(details[0], speech = speech, speed = speed, hold = hold, action_id = this.unique_actionid)
            else if (action == "PickFlower"
                wT = false
                if (len(details) == 2 and details[1] == "WalkTo=true" 
                    wT = true
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.pickFlower(None, speech = speech,  action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.pickFlower(int(details[0]), speech = speech, action_id = this.unique_actionid, walkTo = wT)                    
            else if (action == "PutFlowerDown"
                wT = -1
                if (len(details) == 1
                    wT = int(details[0].split("=")[1]) 
                actionStarted = agent.putdownFlower(action_id = this.unique_actionid, walkTo=wT)
            else if (action == "PutFlowerInPot"
                if (details != None
                    actionStarted = agent.putFlowerInPot(int(details[0]), action_id = this.unique_actionid)
                else
                    actionStarted = agent.putFlowerInPot(details, action_id = this.unique_actionid)
            else if (action == "PutFlowerInBasket"
                wt = false
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.putFlowerInBasket(None, action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.putFlowerInBasket(int(details[0]), action_id = this.unique_actionid, walkTo = wT)                    
            else if (action == "TouchObject"
                wt = false
                object_id = None
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (details[0]
                    object_id = int(details[0])    
                actionStarted = agent.touchObject(object_id, action_id = this.unique_actionid, speech = speech, walkTo=wT)
            else if (action == "TouchFlower"
                flower_id = None
                if (len(details) == 1 and details[0]
                    flower_id = int(details[0])
                actionStarted = agent.touchFlower(flower_id, action_id = this.unique_actionid, speech = speech)
            else if (action == "TouchFlower-Bubble"
                flower_id = None
                if (len(details) == 1 and details[0]
                    flower_id = int(details[0])
                actionStarted = agent.touchFlower(flower_id, target="Bubble", action_id = this.unique_actionid, speech = speech)
            else if (action == "TouchFlower-Ball"
                flower_id = None
                if (len(details) == 1 and details[0]
                    flower_id = int(details[0])
                actionStarted = agent.touchFlower(flower_id, target="Ball", action_id = this.unique_actionid, speech = speech)
            else if (action == "PickUpPot"
                wT = false
                if (len(details) == 2 and details[1] == "WalkTo=true" 
                    wT = true
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.pickupPot(None, action_id = this.unique_actionid, walkTo = wT, speech = speech)
                else
                    actionStarted = agent.pickupPot(int(details[0]), action_id = this.unique_actionid, walkTo = wT, speech = speech )
            else if (action == "PutPotDown"
                wT = -1
                if (len(details) == 1
                    wT = int(details[0].split("=")[1]) 
                actionStarted = agent.putdownPot(action_id = this.unique_actionid, walkTo=wT)
            else if (action == "StackPot"
                wT = false
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.stackPot(None, action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.stackPot(int(details[0]), action_id = this.unique_actionid, walkTo = wT)
            else if (action == "PickUpBasket"
                wT = false
                if (len(details) == 2 and details[1] == "WalkTo=true" 
                    wT = true
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.pickupBasket(None, action_id = this.unique_actionid, walkTo = wT, speech = speech)
                else
                    actionStarted = agent.pickupBasket(int(details[0]), action_id = this.unique_actionid, walkTo = wT, speech = speech )
            else if (action == "PutBasketDown"
                wT = -1
                if (len(details) == 1
                    wT = int(details[0].split("=")[1]) 
                actionStarted = agent.putdownBasket(action_id = this.unique_actionid, walkTo=wT)
            else if (action == "PickUpBall"
                wT = false
                if (len(details) == 2 and details[1] == "WalkTo=true" 
                    wT = true
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.pickupBall(None, action_id = this.unique_actionid, walkTo = wT, speech = speech)
                else
                    actionStarted = agent.pickupBall(int(details[0]), action_id = this.unique_actionid, walkTo = wT, speech = speech )
            else if (action == "PutBallDown"
                wT = -1
                if (len(details) == 1
                    wT = int(details[0].split("=")[1]) 
                actionStarted = agent.putdownBall(action_id = this.unique_actionid, walkTo=wT)
            else if (action == "PutBallIntoContainer"
                wT = false
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.putBallIntoContainer(None, action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.putBallIntoContainer(int(details[0]), action_id = this.unique_actionid, walkTo = wT)
            else if (action == "ThrowBall"
                cid = None
                if (len(details) > 0 and details[0] != None
                    cid = int(details[0]) 
                actionStarted = agent.throwBall(action_id = this.unique_actionid, cloudId = cid)
            else if (action == "MakeRain"
                wt = false
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.makeRain(None, action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.makeRain(int(details[0]), action_id = this.unique_actionid, walkTo = wT)                    
            else if (action == "TouchLeaves"
                actionStarted = agent.touchLeaves(None, action_id = this.unique_actionid)
            else if (action == "AttachCloud"
                if (details != None
                    actionStarted = agent.attachCloud(int(details[0]), action_id = this.unique_actionid)
                else
                    actionStarted = agent.attachCloud(None, action_id = this.unique_actionid)
            else if (action == "DetachCloud"
                actionStarted = agent.detachCloud(action_id = this.unique_actionid)
            else if (action == "Say"
                idx = 0
                for file in details
                    if (idx == len(details) - 1 
                        actionStarted = agent.sayPreRecorded(file, action_id = this.unique_actionid)
                    else 
                        actionStarted = agent.sayPreRecorded(file, action_id = None)
                    idx += 1
                    
            else if (action == "FacialExpression"
                actionStarted = agent.setFacialExpression(details[0], action_id = this.unique_actionid)
                
            else if (action == "Blinking"
                if (details[0] == "true"
                    actionStarted = agent.blinking(true)
                actionStarted = agent.blinking(false)

            if (actionStarted
                this.app.canvas.agentActionStarted(_cb, this.unique_actionid, agentId, action, orig_details)
                _cb.ice_response(true)
                if (action == "FacialExpression" or action == "AttachCloud" or action == "DetachCloud"
                    this.app.canvas.agentActionCompleted(this.unique_actionid, true)
            else
                # Logger.warning("Unknown action " + action)
                _cb.ice_response(false)
        else
            Logger.warning("Unknown agent " + str(agentId))
            _cb.ice_response(false)
    
    ## initiate a demo by the agent (not used)      
    public void initAgentDemo(agentId, actionName, numObjects, current=None)
        pass
    
    ## Add an object to the scene
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                             
    public void addObject_async(_cb, objectType, current=None)
        Logger.trace("info", "addObject " + objectType)
        evt = AddObject(type=objectType, callback=_cb)
        wx.PostEvent(this.app.canvas, evt)

    ## Remove an object from the scene
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                                     
    public void removeObject_async(_cb, objId, current=None)
        Logger.trace("info", "removeObject " + objId)
        evt = RemoveObject(objId=objId, callback=_cb)
        wx.PostEvent(this.app.canvas, evt)

    ## Set a property on a certain object
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                             
    public void setObjectProperty(objId, propName, propValue, current=None)
        Logger.trace("info", "setObjectProperty " + str(objId) + " " + str(propName) + " " + str(propValue))
        evt = SetObjectProperty(objId=objId, propName=propName, propValue=propValue)
        wx.PostEvent(this.app.canvas, evt)
        
    ## Query the probability of the child's attention to a specific object (unused)
    public void getAttentionProbability(objectId, current=None)
        Logger.trace("info", "querying the attention probability for object" + str(objectId))
        # do something like 
        # this.app.canvas.viProxy.getAttentionProbability....

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:178)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:114)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136)
	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105)
	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:406)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 17:39:31.600
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:178)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:114)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136)
	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105)
	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:406)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 17:39:31.602
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:178)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:114)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136)
	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105)
	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:406)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 17:39:31.765
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
## @package interface.RenderingEngineImpl
# Implementation of the rendering engine interface
# @authors Chris, Mef
import Ice
import Logger
import echoes
import objects.Bubbles
import objects.Plants
import agents.PiavcaAvatars
import environment.Backgrounds
import environment.HelperElements
import environment.Menu
import objects.Environment
import visual.Annotator
from visual.EchoesGLCanvas import CreatePiavcaAvatar, LoadScenario, EndScenario, AddObject, SetObjectProperty, RemoveObject, StartAnnotator, StopAnnotator, AnnotatorDrawing, AnnotatorNoDrawing
import wx
import math

## Implementation of the rendering engine interface called from other modules via ICE 
#
#    
public class RenderingEngineImpl(echoes.RenderingEngine)
    ## 
    #
    public void __init__(rlPublisher)
        ## Reference to the main application.
        this.app = app
        ## The publisher to publish events to rendering engine listeners.
        this.rlPublisher = rlPublisher
        ## Counter of unique action ids.
        this.unique_actionid = 0
        ## Record of action ids currently being processed.
        this.currentActions = dict()

    ## Loading scenarios by name
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas 
    public void loadScenario_async(_cb, name, current=None)
        Logger.trace("info", "loadScenario " + name)
        
        evt = LoadScenario(name=name, callback=_cb)
        wx.PostEvent(this.app.canvas, evt)
        
    ## Ending scenarios by name
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas             
    public void endScenario_async(_cb, name, current=None)
        Logger.trace("info", "endScenario " + name)
        
        evt = EndScenario(name=name, callback=_cb)
        wx.PostEvent(this.app.canvas, evt)

    ## Set a property of the world
    # @param propName Name of the property to be set as string
    # @param propValue Value of the property as string
    #
    # Available properties are
    # - \b UserList set the user list for the intro screen (space separated string of names)
    # - \b numBubbles number of bubbles in the scene 
    # - \b DisplayScore display a score (true/false)
    # - \b SetScore set the score (integer)
    # - \b IncrementScore increment the score
    # - \b LightLevel setting the light level of the scene (0 to 1)
    # - \b Annotator show the Annotator overlay (true/false)
    # - \b AnnotatorDrawing enable drawing on the Annotator overlay (true/false)
    public void setWorldProperty(propName, propValue, current=None)
        Logger.trace("info", "setWorldProperty " + propName + " " + propValue)

        if ("Score" in propName
            bs = None
            for id, object in this.app.canvas.sceneElements.items()
                if (isinstance(object, environment.HelperElements.Score)
                    bs = object
                    break

        if ((propName == "UserList")
            this.app.canvas.userList = propValue.split(' ')

        else if ((propName == "numBubbles")
            targetNum = int(propValue)
            curBubbles = [] 
            for id,object in this.app.canvas.objects.items()
                if (isinstance(object, objects.Bubbles.EchoesBubble)
                    curBubbles.append(object)
            if ((len(curBubbles) < targetNum)
                for i in range (0, targetNum - len(curBubbles))
                    evt = AddObject(type="Bubble", callback=None)
                    wx.PostEvent(this.app.canvas, evt)
            else
                while (len(curBubbles) > targetNum)
                    curBubbles.pop().remove()

        else if (propName == "DisplayScore"
            if (propValue == "false" and bs != None
                bs.remove()
            if (propValue == "true" and bs == None
                environment.HelperElements.Score(this.app)
                
        else if (propName == "SetScore" and bs
            bs.setScore(int(propValue))

        else if (propName == "IncrementScore" and bs
            bs.increment()

        else if (propName == "LightLevel"
            this.app.canvas.targetLightLevel = float(propValue) 
                
        else if (propName == "Annotator"
            if (propValue == "true" 
                evt = StartAnnotator()
            else
                evt = StopAnnotator()    
            wx.PostEvent(this.app.canvas, evt)
        else if (propName == "AnnotatorDrawing"
            if (propValue == "true" 
                evt = AnnotatorDrawing()
            else
                evt = AnnotatorNoDrawing()    
            wx.PostEvent(this.app.canvas, evt)

    ## Add an agent with a certain pose
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                             
    public void addAgentWithPose_async(_cb, agentType, pose, current=None)
        Logger.trace("info", "addAgentWithPose " + agentType)
        if (agentType == "Paul"
            # this needs to be done via wx.Events because the ICE callbacks reside in a different thread    
            evt = CreatePiavcaAvatar(type="Paul", autoadd=true, pose=pose, callback=_cb)
            wx.PostEvent(this.app.canvas, evt)
        else
            this.addAgent_async(_cb, agentType, current)

    ## Add an agent to the scene
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                         
    public void addAgent_async(_cb, agentType, current=None)
        Logger.trace("info", "addAgent " + agentType)
        if (agentType == "Paul"        
            # this needs to be done via wx.Events because the ICE callbacks reside in a different thread    
            evt = CreatePiavcaAvatar(type="Paul", autoadd=true, callback=_cb)
            wx.PostEvent(this.app.canvas, evt)
        else if (agentType == "Andy"        
            # this needs to be done via wx.Events because the ICE callbacks reside in a different thread    
            evt = CreatePiavcaAvatar(type="Andy", autoadd=true, callback=_cb)
            wx.PostEvent(this.app.canvas, evt)
        else
            Logger.warning("Cannot create agent of type " + agentType)
            _cb.ice_response("")

    ## Remove an agent from the scene
    #
    public void removeAgent(agentId, current=None)
        this.app.canvas.agents[int(agentId)].remove() 

    ## Call on an agent to execute an action 
    # @param agentId the id of the agent that is called upon
    # @param action the action the agent is asked to perform as string
    # @param details details for the action as a list of strings 
    # @return Boolean whether the action has been started successfully or failed (e.g., if (certain preconditions are not fulfilled)
    #
    # The following \b actions and their corresponding details (in brackets, optional details in \e italic) are available
    # - \b LookAtPoint [x, y, z, \e "speech1.wav,speech2.wav", \e "speed=1.0", \e "hold=0.0"] \b Note All speech is optional and synchronised with gestures or movements, \e speed is a timefactor for the motion and \e hold determines how long the agent holds the gesture before moving on
    # - \b LookAtObject [objectId, \e"speech1.wav,speech2.wav", \e "speed=1.0", \e "hold=0.0"]
    # - \b LookAtChild [\e "speech1.wav,speech2.wav", \e "speed=1.0", \e "hold=0.0"]
    # - \b PointAt [objectId, \e "speed=1.0", \e "hold=0.0"]
    # - \b PointAtPoint [x, y, z, \e "speed=1.0", \e "hold=0.0"]
    # - \b TurnTo [objectId]
    # - \b TurnToPoint [x, z]
    # - \b TurnToChild []
    # - \b SetPosition[x,z]    \b Note instant relocation of the agent
    # - \b SetDepthLayer["front"/"back"]    \b Note instant relocation and scaling of the agent to appear in the back
    # - \b WalkTo [x, z]
    # - \b WalkToObject [objectId]
    # - \b ResetPosture []
    # - \b Gesture [gesture, \e "x,z", \e "speech1.wav,speech2.wav", \e "speed=1.0", \e "hold=0.0"] \b Note second argument is optional orientation after gesture       
    # - \b TouchObject [objectId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"] \b Note the WalkTo flag causes the agent to walk to the object before performing the action
    # - \b PickFlower ([flowerId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"]
    # - \b PutFlowerDown ["WalkTo=0-9"] \b Note 0-9 indicate vertical slots in the scene from left to right
    # - \b PutFlowerInPot [\e potId] \b Note optional object ids cause the agent to use any suitable object in the scene
    # - \b PutFlowerInBasket[\e basketId, \e "WalkTo=true"]
    # - \b TouchFlower [\e flowerId, \e "speech1.wav,speech2.wav"]
    # - \b TouchFlower-Bubble [\e flowerId, \e "speech1.wav,speech2.wav"]
    # - \b TouchFlower-Ball [\e flowerId, \e "speech1.wav,speech2.wav"]
    # - \b PickUpPot [\e potId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"]
    # - \b PutPotDown [\e "WalkTo=0-9"]
    # - \b StackPot [\e potId, \e "WalkTo=true"]
    # - \b PickUpBasket [\e basketId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"]
    # - \b PutBasketDown ([\e "WalkTo=0-9"]
    # - \b MakeRain [\e cloudId, \e "WalkTo=true"]
    # - \b TouchLeaves [\e leavesId]
    # - \b AttachCloud [\e cloudId]
    # - \b DetachCloud []
    # - \b PopBubble [\e bubbleId]
    # - \b Say ["speech1.wav,speech2.wav"]
    # - \b PickUpBall [\e ballId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"]
    # - \b PutBallDown [\e "WalkTo=0-9"]
    # - \b ThrowBall [\e cloudId] \b Note if (cloudId is given, agent walks to the cloud and the ball is thrown through the cloud 
    # - \b PutBallIntoContainer [\e containerId, \e "WalkTo=true"]
    public void executeAction_async(_cb, agentId, action, details, current=None)
        this.unique_actionid +=1
        orig_details = details[]
        Logger.trace("info", "executeAction " + str(agentId) + " " + str(action) + " " + str(details) + " unique action id " + str(this.unique_actionid))
        try
            agent = this.app.canvas.agents[int(agentId)]
        except KeyError
            Logger.trace("Warning", "No agent with ID " + str(agentId) + " found")
            print str("Here are the available agents " + str(this.app.canvas.agents))
            agent = None    
        if (agent
            speech = None 
            speed = 1.0
            hold = 0.0
            try
                for detail in details
                    if (detail and ".wav" in detail
                        speech = detail
                        del details[details.index(detail)]
                        break
                for detail in details
                    if (detail and "speed" in detail
                        speed = float(detail.split("=")[1])
                        del details[details.index(detail)]
                        break
                for detail in details
                    if (detail and "hold" in detail
                        hold = float(detail.split("=")[1])
                        del details[details.index(detail)]
                        break
            except
                Logger.warning("executeAction was called with details which are not in a list, this might cause problems")
            actionStarted = false
            if (action == "LookAtObject"
                actionStarted = agent.lookAtObject(int(details[0]), speech=speech, speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "LookAtPoint"
                actionStarted = agent.lookAtPoint(float(details[0]), float(details[1]), float(details[2]), speech=speech, speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "LookAtChild"
                actionStarted = agent.lookAtChild(speech=speech, speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "PointAt"
                actionStarted = agent.pointAt(int(details[0]), speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "PointAtPoint"
                actionStarted = agent.pointAtPoint(float(details[0]), float(details[1]), float(details[2]), speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "TurnTo"
                actionStarted = agent.turnTo(int(details[0]), action_id = this.unique_actionid)
            else if (action == "TurnToPoint"
                actionStarted = agent.turnToPoint(float(details[0]), float(details[1]), action_id = this.unique_actionid)
            else if (action == "TurnToChild"
                actionStarted = agent.turnToChild(action_id = this.unique_actionid)
            else if (action == "PopBubble"
                actionStarted = agent.popBubble(int(details[0]), action_id = this.unique_actionid)
            else if (action == "WalkTo"
                actionStarted = agent.walkTo(float(details[0]), float(details[1]), action_id = this.unique_actionid)
            else if (action == "WalkToObject"
                actionStarted = agent.walkToObject(int(details[0]), action_id = this.unique_actionid)
            else if (action == "SetPosition"
                actionStarted = agent.setPosition([float(details[0]), float(details[1])], action_id = this.unique_actionid)
            else if (action == "SetDepthLayer"
                actionStarted = agent.setDepthLayer(details[0], action_id = this.unique_actionid)
            else if (action == "ResetPosture"
                actionStarted = agent.resetPosture(action_id = this.unique_actionid)
            else if (action == "Gesture"
                if (len(details) == 2
                    if (details[1] == "child"
                        actionStarted = agent.gesture(details[0], orientation=["child"], speech = speech, speed = speed, hold = hold, action_id = this.unique_actionid)
                    else
                        x, z = details[1].split(",")
                        actionStarted = agent.gesture(details[0], orientation=(float(x), float(z)), speech = speech, speed = speed, hold = hold, action_id = this.unique_actionid)
                else 
                    actionStarted = agent.gesture(details[0], speech = speech, speed = speed, hold = hold, action_id = this.unique_actionid)
            else if (action == "PickFlower"
                wT = false
                if (len(details) == 2 and details[1] == "WalkTo=true" 
                    wT = true
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.pickFlower(None, speech = speech,  action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.pickFlower(int(details[0]), speech = speech, action_id = this.unique_actionid, walkTo = wT)                    
            else if (action == "PutFlowerDown"
                wT = -1
                if (len(details) == 1
                    wT = int(details[0].split("=")[1]) 
                actionStarted = agent.putdownFlower(action_id = this.unique_actionid, walkTo=wT)
            else if (action == "PutFlowerInPot"
                if (details != None
                    actionStarted = agent.putFlowerInPot(int(details[0]), action_id = this.unique_actionid)
                else
                    actionStarted = agent.putFlowerInPot(details, action_id = this.unique_actionid)
            else if (action == "PutFlowerInBasket"
                wt = false
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.putFlowerInBasket(None, action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.putFlowerInBasket(int(details[0]), action_id = this.unique_actionid, walkTo = wT)                    
            else if (action == "TouchObject"
                wt = false
                object_id = None
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (details[0]
                    object_id = int(details[0])    
                actionStarted = agent.touchObject(object_id, action_id = this.unique_actionid, speech = speech, walkTo=wT)
            else if (action == "TouchFlower"
                flower_id = None
                if (len(details) == 1 and details[0]
                    flower_id = int(details[0])
                actionStarted = agent.touchFlower(flower_id, action_id = this.unique_actionid, speech = speech)
            else if (action == "TouchFlower-Bubble"
                flower_id = None
                if (len(details) == 1 and details[0]
                    flower_id = int(details[0])
                actionStarted = agent.touchFlower(flower_id, target="Bubble", action_id = this.unique_actionid, speech = speech)
            else if (action == "TouchFlower-Ball"
                flower_id = None
                if (len(details) == 1 and details[0]
                    flower_id = int(details[0])
                actionStarted = agent.touchFlower(flower_id, target="Ball", action_id = this.unique_actionid, speech = speech)
            else if (action == "PickUpPot"
                wT = false
                if (len(details) == 2 and details[1] == "WalkTo=true" 
                    wT = true
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.pickupPot(None, action_id = this.unique_actionid, walkTo = wT, speech = speech)
                else
                    actionStarted = agent.pickupPot(int(details[0]), action_id = this.unique_actionid, walkTo = wT, speech = speech )
            else if (action == "PutPotDown"
                wT = -1
                if (len(details) == 1
                    wT = int(details[0].split("=")[1]) 
                actionStarted = agent.putdownPot(action_id = this.unique_actionid, walkTo=wT)
            else if (action == "StackPot"
                wT = false
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.stackPot(None, action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.stackPot(int(details[0]), action_id = this.unique_actionid, walkTo = wT)
            else if (action == "PickUpBasket"
                wT = false
                if (len(details) == 2 and details[1] == "WalkTo=true" 
                    wT = true
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.pickupBasket(None, action_id = this.unique_actionid, walkTo = wT, speech = speech)
                else
                    actionStarted = agent.pickupBasket(int(details[0]), action_id = this.unique_actionid, walkTo = wT, speech = speech )
            else if (action == "PutBasketDown"
                wT = -1
                if (len(details) == 1
                    wT = int(details[0].split("=")[1]) 
                actionStarted = agent.putdownBasket(action_id = this.unique_actionid, walkTo=wT)
            else if (action == "PickUpBall"
                wT = false
                if (len(details) == 2 and details[1] == "WalkTo=true" 
                    wT = true
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.pickupBall(None, action_id = this.unique_actionid, walkTo = wT, speech = speech)
                else
                    actionStarted = agent.pickupBall(int(details[0]), action_id = this.unique_actionid, walkTo = wT, speech = speech )
            else if (action == "PutBallDown"
                wT = -1
                if (len(details) == 1
                    wT = int(details[0].split("=")[1]) 
                actionStarted = agent.putdownBall(action_id = this.unique_actionid, walkTo=wT)
            else if (action == "PutBallIntoContainer"
                wT = false
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.putBallIntoContainer(None, action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.putBallIntoContainer(int(details[0]), action_id = this.unique_actionid, walkTo = wT)
            else if (action == "ThrowBall"
                cid = None
                if (len(details) > 0 and details[0] != None
                    cid = int(details[0]) 
                actionStarted = agent.throwBall(action_id = this.unique_actionid, cloudId = cid)
            else if (action == "MakeRain"
                wt = false
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.makeRain(None, action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.makeRain(int(details[0]), action_id = this.unique_actionid, walkTo = wT)                    
            else if (action == "TouchLeaves"
                actionStarted = agent.touchLeaves(None, action_id = this.unique_actionid)
            else if (action == "AttachCloud"
                if (details != None
                    actionStarted = agent.attachCloud(int(details[0]), action_id = this.unique_actionid)
                else
                    actionStarted = agent.attachCloud(None, action_id = this.unique_actionid)
            else if (action == "DetachCloud"
                actionStarted = agent.detachCloud(action_id = this.unique_actionid)
            else if (action == "Say"
                idx = 0
                for file in details
                    if (idx == len(details) - 1 
                        actionStarted = agent.sayPreRecorded(file, action_id = this.unique_actionid)
                    else 
                        actionStarted = agent.sayPreRecorded(file, action_id = None)
                    idx += 1
                    
            else if (action == "FacialExpression"
                actionStarted = agent.setFacialExpression(details[0], action_id = this.unique_actionid)
                
            else if (action == "Blinking"
                if (details[0] == "true"
                    actionStarted = agent.blinking(true)
                actionStarted = agent.blinking(false)

            if (actionStarted
                this.app.canvas.agentActionStarted(_cb, this.unique_actionid, agentId, action, orig_details)
                _cb.ice_response(true)
                if (action == "FacialExpression" or action == "AttachCloud" or action == "DetachCloud"
                    this.app.canvas.agentActionCompleted(this.unique_actionid, true)
            else
                # Logger.warning("Unknown action " + action)
                _cb.ice_response(false)
        else
            Logger.warning("Unknown agent " + str(agentId))
            _cb.ice_response(false)
    
    ## initiate a demo by the agent (not used)      
    public void initAgentDemo(agentId, actionName, numObjects, current=None)
        pass
    
    ## Add an object to the scene
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                             
    public void addObject_async(_cb, objectType, current=None)
        Logger.trace("info", "addObject " + objectType)
        evt = AddObject(type=objectType, callback=_cb)
        wx.PostEvent(this.app.canvas, evt)

    ## Remove an object from the scene
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                                     
    public void removeObject_async(_cb, objId, current=None)
        Logger.trace("info", "removeObject " + objId)
        evt = RemoveObject(objId=objId, callback=_cb)
        wx.PostEvent(this.app.canvas, evt)

    ## Set a property on a certain object
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                             
    public void setObjectProperty(objId, propName, propValue, current=None)
        Logger.trace("info", "setObjectProperty " + str(objId) + " " + str(propName) + " " + str(propValue))
        evt = SetObjectProperty(objId=objId, propName=propName, propValue=propValue)
        wx.PostEvent(this.app.canvas, evt)
        
    ## Query the probability of the child's attention to a specific object (unused)
    public void getAttentionProbability(objectId, current=None)
        Logger.trace("info", "querying the attention probability for object" + str(objectId))
        # do something like 
        # this.app.canvas.viProxy.getAttentionProbability....

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 17:39:31.768
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 17:39:31.770
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 17:39:38.519
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
## @package interface.RenderingEngineImpl
# Implementation of the rendering engine interface
# @authors Chris, Mef
import Ice
import Logger
import echoes
import objects.Bubbles
import objects.Plants
import agents.PiavcaAvatars
import environment.Backgrounds
import environment.HelperElements
import environment.Menu
import objects.Environment
import visual.Annotator
from visual.EchoesGLCanvas import CreatePiavcaAvatar, LoadScenario, EndScenario, AddObject, SetObjectProperty, RemoveObject, StartAnnotator, StopAnnotator, AnnotatorDrawing, AnnotatorNoDrawing
import wx
import math

## Implementation of the rendering engine interface called from other modules via ICE 
#
#    
public class RenderingEngineImpl(echoes.RenderingEngine)
    ## 
    #
    public void __init__(rlPublisher)
        ## Reference to the main application.
        this.app = app
        ## The publisher to publish events to rendering engine listeners.
        this.rlPublisher = rlPublisher
        ## Counter of unique action ids.
        this.unique_actionid = 0
        ## Record of action ids currently being processed.
        this.currentActions = dict()

    ## Loading scenarios by name
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas 
    public void loadScenario_async(_cb, name, current=None)
        Logger.trace("info", "loadScenario " + name)
        
        evt = LoadScenario(name=name, callback=_cb)
        wx.PostEvent(this.app.canvas, evt)
        
    ## Ending scenarios by name
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas             
    public void endScenario_async(_cb, name, current=None)
        Logger.trace("info", "endScenario " + name)
        
        evt = EndScenario(name=name, callback=_cb)
        wx.PostEvent(this.app.canvas, evt)

    ## Set a property of the world
    # @param propName Name of the property to be set as string
    # @param propValue Value of the property as string
    #
    # Available properties are
    # - \b UserList set the user list for the intro screen (space separated string of names)
    # - \b numBubbles number of bubbles in the scene 
    # - \b DisplayScore display a score (true/false)
    # - \b SetScore set the score (integer)
    # - \b IncrementScore increment the score
    # - \b LightLevel setting the light level of the scene (0 to 1)
    # - \b Annotator show the Annotator overlay (true/false)
    # - \b AnnotatorDrawing enable drawing on the Annotator overlay (true/false)
    public void setWorldProperty(propName, propValue, current=None)
        Logger.trace("info", "setWorldProperty " + propName + " " + propValue)

        if ("Score" in propName
            bs = None
            for id, object in this.app.canvas.sceneElements.items()
                if (isinstance(object, environment.HelperElements.Score)
                    bs = object
                    break

        if ((propName == "UserList")
            this.app.canvas.userList = propValue.split(' ')

        else if ((propName == "numBubbles")
            targetNum = int(propValue)
            curBubbles = [] 
            for id,object in this.app.canvas.objects.items()
                if (isinstance(object, objects.Bubbles.EchoesBubble)
                    curBubbles.append(object)
            if ((len(curBubbles) < targetNum)
                for i in range (0, targetNum - len(curBubbles))
                    evt = AddObject(type="Bubble", callback=None)
                    wx.PostEvent(this.app.canvas, evt)
            else
                while (len(curBubbles) > targetNum)
                    curBubbles.pop().remove()

        else if (propName == "DisplayScore"
            if (propValue == "false" and bs != None
                bs.remove()
            if (propValue == "true" and bs == None
                environment.HelperElements.Score(this.app)
                
        else if (propName == "SetScore" and bs
            bs.setScore(int(propValue))

        else if (propName == "IncrementScore" and bs
            bs.increment()

        else if (propName == "LightLevel"
            this.app.canvas.targetLightLevel = float(propValue) 
                
        else if (propName == "Annotator"
            if (propValue == "true" 
                evt = StartAnnotator()
            else
                evt = StopAnnotator()    
            wx.PostEvent(this.app.canvas, evt)
        else if (propName == "AnnotatorDrawing"
            if (propValue == "true" 
                evt = AnnotatorDrawing()
            else
                evt = AnnotatorNoDrawing()    
            wx.PostEvent(this.app.canvas, evt)

    ## Add an agent with a certain pose
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                             
    public void addAgentWithPose_async(_cb, agentType, pose, current=None)
        Logger.trace("info", "addAgentWithPose " + agentType)
        if (agentType == "Paul"
            # this needs to be done via wx.Events because the ICE callbacks reside in a different thread    
            evt = CreatePiavcaAvatar(type="Paul", autoadd=true, pose=pose, callback=_cb)
            wx.PostEvent(this.app.canvas, evt)
        else
            this.addAgent_async(_cb, agentType, current)

    ## Add an agent to the scene
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                         
    public void addAgent_async(_cb, agentType, current=None)
        Logger.trace("info", "addAgent " + agentType)
        if (agentType == "Paul"        
            # this needs to be done via wx.Events because the ICE callbacks reside in a different thread    
            evt = CreatePiavcaAvatar(type="Paul", autoadd=true, callback=_cb)
            wx.PostEvent(this.app.canvas, evt)
        else if (agentType == "Andy"        
            # this needs to be done via wx.Events because the ICE callbacks reside in a different thread    
            evt = CreatePiavcaAvatar(type="Andy", autoadd=true, callback=_cb)
            wx.PostEvent(this.app.canvas, evt)
        else
            Logger.warning("Cannot create agent of type " + agentType)
            _cb.ice_response("")

    ## Remove an agent from the scene
    #
    public void removeAgent(agentId, current=None)
        this.app.canvas.agents[int(agentId)].remove() 

    ## Call on an agent to execute an action 
    # @param agentId the id of the agent that is called upon
    # @param action the action the agent is asked to perform as string
    # @param details details for the action as a list of strings 
    # @return Boolean whether the action has been started successfully or failed (e.g., if (certain preconditions are not fulfilled)
    #
    # The following \b actions and their corresponding details (in brackets, optional details in \e italic) are available
    # - \b LookAtPoint [x, y, z, \e "speech1.wav,speech2.wav", \e "speed=1.0", \e "hold=0.0"] \b Note All speech is optional and synchronised with gestures or movements, \e speed is a timefactor for the motion and \e hold determines how long the agent holds the gesture before moving on
    # - \b LookAtObject [objectId, \e"speech1.wav,speech2.wav", \e "speed=1.0", \e "hold=0.0"]
    # - \b LookAtChild [\e "speech1.wav,speech2.wav", \e "speed=1.0", \e "hold=0.0"]
    # - \b PointAt [objectId, \e "speed=1.0", \e "hold=0.0"]
    # - \b PointAtPoint [x, y, z, \e "speed=1.0", \e "hold=0.0"]
    # - \b TurnTo [objectId]
    # - \b TurnToPoint [x, z]
    # - \b TurnToChild []
    # - \b SetPosition[x,z]    \b Note instant relocation of the agent
    # - \b SetDepthLayer["front"/"back"]    \b Note instant relocation and scaling of the agent to appear in the back
    # - \b WalkTo [x, z]
    # - \b WalkToObject [objectId]
    # - \b ResetPosture []
    # - \b Gesture [gesture, \e "x,z", \e "speech1.wav,speech2.wav", \e "speed=1.0", \e "hold=0.0"] \b Note second argument is optional orientation after gesture       
    # - \b TouchObject [objectId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"] \b Note the WalkTo flag causes the agent to walk to the object before performing the action
    # - \b PickFlower ([flowerId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"]
    # - \b PutFlowerDown ["WalkTo=0-9"] \b Note 0-9 indicate vertical slots in the scene from left to right
    # - \b PutFlowerInPot [\e potId] \b Note optional object ids cause the agent to use any suitable object in the scene
    # - \b PutFlowerInBasket[\e basketId, \e "WalkTo=true"]
    # - \b TouchFlower [\e flowerId, \e "speech1.wav,speech2.wav"]
    # - \b TouchFlower-Bubble [\e flowerId, \e "speech1.wav,speech2.wav"]
    # - \b TouchFlower-Ball [\e flowerId, \e "speech1.wav,speech2.wav"]
    # - \b PickUpPot [\e potId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"]
    # - \b PutPotDown [\e "WalkTo=0-9"]
    # - \b StackPot [\e potId, \e "WalkTo=true"]
    # - \b PickUpBasket [\e basketId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"]
    # - \b PutBasketDown ([\e "WalkTo=0-9"]
    # - \b MakeRain [\e cloudId, \e "WalkTo=true"]
    # - \b TouchLeaves [\e leavesId]
    # - \b AttachCloud [\e cloudId]
    # - \b DetachCloud []
    # - \b PopBubble [\e bubbleId]
    # - \b Say ["speech1.wav,speech2.wav"]
    # - \b PickUpBall [\e ballId, \e "WalkTo=true", \e "speech1.wav,speech2.wav"]
    # - \b PutBallDown [\e "WalkTo=0-9"]
    # - \b ThrowBall [\e cloudId] \b Note if (cloudId is given, agent walks to the cloud and the ball is thrown through the cloud 
    # - \b PutBallIntoContainer [\e containerId, \e "WalkTo=true"]
    public void executeAction_async(_cb, agentId, action, details, current=None)
        this.unique_actionid +=1
        orig_details = details[]
        Logger.trace("info", "executeAction " + str(agentId) + " " + str(action) + " " + str(details) + " unique action id " + str(this.unique_actionid))
        try
            agent = this.app.canvas.agents[int(agentId)]
        except KeyError
            Logger.trace("Warning", "No agent with ID " + str(agentId) + " found")
            print str("Here are the available agents " + str(this.app.canvas.agents))
            agent = None    
        if (agent
            speech = None 
            speed = 1.0
            hold = 0.0
            try
                for detail in details
                    if (detail and ".wav" in detail
                        speech = detail
                        del details[details.index(detail)]
                        break
                for detail in details
                    if (detail and "speed" in detail
                        speed = float(detail.split("=")[1])
                        del details[details.index(detail)]
                        break
                for detail in details
                    if (detail and "hold" in detail
                        hold = float(detail.split("=")[1])
                        del details[details.index(detail)]
                        break
            except
                Logger.warning("executeAction was called with details which are not in a list, this might cause problems")
            actionStarted = false
            if (action == "LookAtObject"
                actionStarted = agent.lookAtObject(int(details[0]), speech=speech, speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "LookAtPoint"
                actionStarted = agent.lookAtPoint(float(details[0]), float(details[1]), float(details[2]), speech=speech, speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "LookAtChild"
                actionStarted = agent.lookAtChild(speech=speech, speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "PointAt"
                actionStarted = agent.pointAt(int(details[0]), speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "PointAtPoint"
                actionStarted = agent.pointAtPoint(float(details[0]), float(details[1]), float(details[2]), speed=speed, hold=hold, action_id = this.unique_actionid)
            else if (action == "TurnTo"
                actionStarted = agent.turnTo(int(details[0]), action_id = this.unique_actionid)
            else if (action == "TurnToPoint"
                actionStarted = agent.turnToPoint(float(details[0]), float(details[1]), action_id = this.unique_actionid)
            else if (action == "TurnToChild"
                actionStarted = agent.turnToChild(action_id = this.unique_actionid)
            else if (action == "PopBubble"
                actionStarted = agent.popBubble(int(details[0]), action_id = this.unique_actionid)
            else if (action == "WalkTo"
                actionStarted = agent.walkTo(float(details[0]), float(details[1]), action_id = this.unique_actionid)
            else if (action == "WalkToObject"
                actionStarted = agent.walkToObject(int(details[0]), action_id = this.unique_actionid)
            else if (action == "SetPosition"
                actionStarted = agent.setPosition([float(details[0]), float(details[1])], action_id = this.unique_actionid)
            else if (action == "SetDepthLayer"
                actionStarted = agent.setDepthLayer(details[0], action_id = this.unique_actionid)
            else if (action == "ResetPosture"
                actionStarted = agent.resetPosture(action_id = this.unique_actionid)
            else if (action == "Gesture"
                if (len(details) == 2
                    if (details[1] == "child"
                        actionStarted = agent.gesture(details[0], orientation=["child"], speech = speech, speed = speed, hold = hold, action_id = this.unique_actionid)
                    else
                        x, z = details[1].split(",")
                        actionStarted = agent.gesture(details[0], orientation=(float(x), float(z)), speech = speech, speed = speed, hold = hold, action_id = this.unique_actionid)
                else 
                    actionStarted = agent.gesture(details[0], speech = speech, speed = speed, hold = hold, action_id = this.unique_actionid)
            else if (action == "PickFlower"
                wT = false
                if (len(details) == 2 and details[1] == "WalkTo=true" 
                    wT = true
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.pickFlower(None, speech = speech,  action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.pickFlower(int(details[0]), speech = speech, action_id = this.unique_actionid, walkTo = wT)                    
            else if (action == "PutFlowerDown"
                wT = -1
                if (len(details) == 1
                    wT = int(details[0].split("=")[1]) 
                actionStarted = agent.putdownFlower(action_id = this.unique_actionid, walkTo=wT)
            else if (action == "PutFlowerInPot"
                if (details != None
                    actionStarted = agent.putFlowerInPot(int(details[0]), action_id = this.unique_actionid)
                else
                    actionStarted = agent.putFlowerInPot(details, action_id = this.unique_actionid)
            else if (action == "PutFlowerInBasket"
                wt = false
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.putFlowerInBasket(None, action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.putFlowerInBasket(int(details[0]), action_id = this.unique_actionid, walkTo = wT)                    
            else if (action == "TouchObject"
                wt = false
                object_id = None
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (details[0]
                    object_id = int(details[0])    
                actionStarted = agent.touchObject(object_id, action_id = this.unique_actionid, speech = speech, walkTo=wT)
            else if (action == "TouchFlower"
                flower_id = None
                if (len(details) == 1 and details[0]
                    flower_id = int(details[0])
                actionStarted = agent.touchFlower(flower_id, action_id = this.unique_actionid, speech = speech)
            else if (action == "TouchFlower-Bubble"
                flower_id = None
                if (len(details) == 1 and details[0]
                    flower_id = int(details[0])
                actionStarted = agent.touchFlower(flower_id, target="Bubble", action_id = this.unique_actionid, speech = speech)
            else if (action == "TouchFlower-Ball"
                flower_id = None
                if (len(details) == 1 and details[0]
                    flower_id = int(details[0])
                actionStarted = agent.touchFlower(flower_id, target="Ball", action_id = this.unique_actionid, speech = speech)
            else if (action == "PickUpPot"
                wT = false
                if (len(details) == 2 and details[1] == "WalkTo=true" 
                    wT = true
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.pickupPot(None, action_id = this.unique_actionid, walkTo = wT, speech = speech)
                else
                    actionStarted = agent.pickupPot(int(details[0]), action_id = this.unique_actionid, walkTo = wT, speech = speech )
            else if (action == "PutPotDown"
                wT = -1
                if (len(details) == 1
                    wT = int(details[0].split("=")[1]) 
                actionStarted = agent.putdownPot(action_id = this.unique_actionid, walkTo=wT)
            else if (action == "StackPot"
                wT = false
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.stackPot(None, action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.stackPot(int(details[0]), action_id = this.unique_actionid, walkTo = wT)
            else if (action == "PickUpBasket"
                wT = false
                if (len(details) == 2 and details[1] == "WalkTo=true" 
                    wT = true
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.pickupBasket(None, action_id = this.unique_actionid, walkTo = wT, speech = speech)
                else
                    actionStarted = agent.pickupBasket(int(details[0]), action_id = this.unique_actionid, walkTo = wT, speech = speech )
            else if (action == "PutBasketDown"
                wT = -1
                if (len(details) == 1
                    wT = int(details[0].split("=")[1]) 
                actionStarted = agent.putdownBasket(action_id = this.unique_actionid, walkTo=wT)
            else if (action == "PickUpBall"
                wT = false
                if (len(details) == 2 and details[1] == "WalkTo=true" 
                    wT = true
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.pickupBall(None, action_id = this.unique_actionid, walkTo = wT, speech = speech)
                else
                    actionStarted = agent.pickupBall(int(details[0]), action_id = this.unique_actionid, walkTo = wT, speech = speech )
            else if (action == "PutBallDown"
                wT = -1
                if (len(details) == 1
                    wT = int(details[0].split("=")[1]) 
                actionStarted = agent.putdownBall(action_id = this.unique_actionid, walkTo=wT)
            else if (action == "PutBallIntoContainer"
                wT = false
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.putBallIntoContainer(None, action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.putBallIntoContainer(int(details[0]), action_id = this.unique_actionid, walkTo = wT)
            else if (action == "ThrowBall"
                cid = None
                if (len(details) > 0 and details[0] != None
                    cid = int(details[0]) 
                actionStarted = agent.throwBall(action_id = this.unique_actionid, cloudId = cid)
            else if (action == "MakeRain"
                wt = false
                if (len(details) > 1
                    if (details[1] == "WalkTo=true" wT = true 
                if (len(details) == 0 or details[0] == None
                    actionStarted = agent.makeRain(None, action_id = this.unique_actionid, walkTo = wT)
                else
                    actionStarted = agent.makeRain(int(details[0]), action_id = this.unique_actionid, walkTo = wT)                    
            else if (action == "TouchLeaves"
                actionStarted = agent.touchLeaves(None, action_id = this.unique_actionid)
            else if (action == "AttachCloud"
                if (details != None
                    actionStarted = agent.attachCloud(int(details[0]), action_id = this.unique_actionid)
                else
                    actionStarted = agent.attachCloud(None, action_id = this.unique_actionid)
            else if (action == "DetachCloud"
                actionStarted = agent.detachCloud(action_id = this.unique_actionid)
            else if (action == "Say"
                idx = 0
                for file in details
                    if (idx == len(details) - 1 
                        actionStarted = agent.sayPreRecorded(file, action_id = this.unique_actionid)
                    else 
                        actionStarted = agent.sayPreRecorded(file, action_id = None)
                    idx += 1
                    
            else if (action == "FacialExpression"
                actionStarted = agent.setFacialExpression(details[0], action_id = this.unique_actionid)
                
            else if (action == "Blinking"
                if (details[0] == "true"
                    actionStarted = agent.blinking(true)
                actionStarted = agent.blinking(false)

            if (actionStarted
                this.app.canvas.agentActionStarted(_cb, this.unique_actionid, agentId, action, orig_details)
                _cb.ice_response(true)
                if (action == "FacialExpression" or action == "AttachCloud" or action == "DetachCloud"
                    this.app.canvas.agentActionCompleted(this.unique_actionid, true)
            else
                # Logger.warning("Unknown action " + action)
                _cb.ice_response(false)
        else
            Logger.warning("Unknown agent " + str(agentId))
            _cb.ice_response(false)
    
    ## initiate a demo by the agent (not used)      
    public void initAgentDemo(agentId, actionName, numObjects, current=None)
        pass
    
    ## Add an object to the scene
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                             
    public void addObject_async(_cb, objectType, current=None)
        Logger.trace("info", "addObject " + objectType)
        evt = AddObject(type=objectType, callback=_cb)
        wx.PostEvent(this.app.canvas, evt)

    ## Remove an object from the scene
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                                     
    public void removeObject_async(_cb, objId, current=None)
        Logger.trace("info", "removeObject " + objId)
        evt = RemoveObject(objId=objId, callback=_cb)
        wx.PostEvent(this.app.canvas, evt)

    ## Set a property on a certain object
    #
    # This method is asynchronous and generates a wx.Event to be processed by the GUI thread in visual.EchoesGLCanvas.EchoesGLCanvas                             
    public void setObjectProperty(objId, propName, propValue, current=None)
        Logger.trace("info", "setObjectProperty " + str(objId) + " " + str(propName) + " " + str(propValue))
        evt = SetObjectProperty(objId=objId, propName=propName, propValue=propValue)
        wx.PostEvent(this.app.canvas, evt)
        
    ## Query the probability of the child's attention to a specific object (unused)
    public void getAttentionProbability(objectId, current=None)
        Logger.trace("info", "querying the attention probability for object" + str(objectId))
        # do something like 
        # this.app.canvas.viProxy.getAttentionProbability....

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 17:39:38.522
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 17:39:38.524
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.ui.workbench 4 0 2012-05-06 18:43:37.094
!MESSAGE Widget disposed too early for part org.eclipse.debug.ui.BreakpointView
!STACK 0
java.lang.RuntimeException: Widget disposed too early for part org.eclipse.debug.ui.BreakpointView
	at org.eclipse.ui.internal.WorkbenchPartReference$1.widgetDisposed(WorkbenchPartReference.java:171)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:808)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:167)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:773)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:446)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3804)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3285)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:170)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4339)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3298)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.ui.workbench 4 0 2012-05-06 18:43:37.099
!MESSAGE Widget disposed too early for part org.eclipse.ui.views.ContentOutline
!STACK 0
java.lang.RuntimeException: Widget disposed too early for part org.eclipse.ui.views.ContentOutline
	at org.eclipse.ui.internal.WorkbenchPartReference$1.widgetDisposed(WorkbenchPartReference.java:171)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:808)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:167)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:773)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:446)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3804)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3285)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:170)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4339)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3298)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.ui.workbench 4 0 2012-05-06 18:43:37.109
!MESSAGE Widget disposed too early for part org.eclipse.debug.ui.VariableView
!STACK 0
java.lang.RuntimeException: Widget disposed too early for part org.eclipse.debug.ui.VariableView
	at org.eclipse.ui.internal.WorkbenchPartReference$1.widgetDisposed(WorkbenchPartReference.java:171)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:808)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:167)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:773)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:446)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3804)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3285)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:170)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4339)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3298)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.ui.workbench 4 0 2012-05-06 18:43:37.114
!MESSAGE Widget disposed too early for part org.eclipse.debug.ui.DebugView
!STACK 0
java.lang.RuntimeException: Widget disposed too early for part org.eclipse.debug.ui.DebugView
	at org.eclipse.ui.internal.WorkbenchPartReference$1.widgetDisposed(WorkbenchPartReference.java:171)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:808)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:167)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:773)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:446)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3804)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3285)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:170)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4339)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3298)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.ui.workbench 4 0 2012-05-06 18:43:37.120
!MESSAGE Widget disposed too early for part org.eclipse.ui.console.ConsoleView
!STACK 0
java.lang.RuntimeException: Widget disposed too early for part org.eclipse.ui.console.ConsoleView
	at org.eclipse.ui.internal.WorkbenchPartReference$1.widgetDisposed(WorkbenchPartReference.java:171)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:808)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:167)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:773)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:446)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3804)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3285)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:170)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4339)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3298)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.ui.workbench 4 0 2012-05-06 18:43:37.124
!MESSAGE Widget disposed too early for part org.eclipse.ui.views.ProblemView
!STACK 0
java.lang.RuntimeException: Widget disposed too early for part org.eclipse.ui.views.ProblemView
	at org.eclipse.ui.internal.WorkbenchPartReference$1.widgetDisposed(WorkbenchPartReference.java:171)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:808)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:167)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:773)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:446)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3804)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3285)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:170)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4339)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3298)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.ui.workbench 4 0 2012-05-06 18:43:37.131
!MESSAGE Widget disposed too early for part org.eclipse.search.ui.views.SearchView
!STACK 0
java.lang.RuntimeException: Widget disposed too early for part org.eclipse.search.ui.views.SearchView
	at org.eclipse.ui.internal.WorkbenchPartReference$1.widgetDisposed(WorkbenchPartReference.java:171)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:808)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:167)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:773)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:446)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3804)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3285)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:170)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4339)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3298)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.ui.workbench 4 0 2012-05-06 18:43:37.136
!MESSAGE Widget disposed too early for part org.eclipse.jdt.ui.PackageExplorer
!STACK 0
java.lang.RuntimeException: Widget disposed too early for part org.eclipse.jdt.ui.PackageExplorer
	at org.eclipse.ui.internal.WorkbenchPartReference$1.widgetDisposed(WorkbenchPartReference.java:171)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:808)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:167)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:773)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:446)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3804)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3285)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:170)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4339)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3298)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.ui.workbench 4 0 2012-05-06 18:43:37.144
!MESSAGE Widget disposed too early for part org.eclipse.jdt.ui.CompilationUnitEditor
!STACK 0
java.lang.RuntimeException: Widget disposed too early for part org.eclipse.jdt.ui.CompilationUnitEditor
	at org.eclipse.ui.internal.WorkbenchPartReference$1.widgetDisposed(WorkbenchPartReference.java:171)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:808)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:167)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:773)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:446)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3804)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3285)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:170)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4339)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3298)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.ui.workbench 4 0 2012-05-06 18:43:37.155
!MESSAGE Widget disposed too early for part org.eclipse.jdt.ui.CompilationUnitEditor
!STACK 0
java.lang.RuntimeException: Widget disposed too early for part org.eclipse.jdt.ui.CompilationUnitEditor
	at org.eclipse.ui.internal.WorkbenchPartReference$1.widgetDisposed(WorkbenchPartReference.java:171)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:808)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:167)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:773)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:446)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3804)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3285)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:170)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4339)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3298)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.ui.workbench 4 0 2012-05-06 18:43:37.160
!MESSAGE Widget disposed too early for part org.eclipse.jdt.ui.CompilationUnitEditor
!STACK 0
java.lang.RuntimeException: Widget disposed too early for part org.eclipse.jdt.ui.CompilationUnitEditor
	at org.eclipse.ui.internal.WorkbenchPartReference$1.widgetDisposed(WorkbenchPartReference.java:171)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:808)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:167)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:773)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:446)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3804)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3285)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:170)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4339)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3298)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.ui.workbench 4 0 2012-05-06 18:43:37.168
!MESSAGE Widget disposed too early for part org.eclipse.jdt.ui.CompilationUnitEditor
!STACK 0
java.lang.RuntimeException: Widget disposed too early for part org.eclipse.jdt.ui.CompilationUnitEditor
	at org.eclipse.ui.internal.WorkbenchPartReference$1.widgetDisposed(WorkbenchPartReference.java:171)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1077)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1058)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:808)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:873)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:167)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:773)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:811)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:446)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3804)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3285)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:170)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4339)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3298)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2526)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4623)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:341)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1610)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2061)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4985)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3114)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3749)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SESSION 2012-05-06 18:52:25.048 -----------------------------------------------
eclipse.buildId=M20110909-1335
java.version=1.7.0
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86_64

!ENTRY org.eclipse.core.resources 2 10035 2012-05-06 18:52:32.342
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.
!SESSION 2012-05-07 09:29:07.682 -----------------------------------------------
eclipse.buildId=M20110909-1335
java.version=1.7.0
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86_64

!ENTRY org.eclipse.jdt.ui 4 10001 2012-05-07 09:34:06.807
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for HashMap [in HashMap.class [in java.util [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryMethod.getAttachedJavadoc(BinaryMethod.java:643)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:462)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:621)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:567)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:559)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:142)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2012-05-07 09:34:06.828
!MESSAGE Timed out while retrieving the attached javadoc for HashMap [in HashMap.class [in java.util [in C:\Program Files\Java\jre7\lib\rt.jar]]] 

!ENTRY org.eclipse.jdt.ui 4 10001 2012-05-07 09:35:02.236
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for Canvas [in Canvas.class [in java.awt [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryMethod.getAttachedJavadoc(BinaryMethod.java:643)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2$2.visit(JavadocContentAccess2.java:681)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2$InheritDocVisitor.visitInheritDoc(JavadocContentAccess2.java:167)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.findAttachedDocInHierarchy(JavadocContentAccess2.java:687)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:466)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:621)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:567)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:559)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:142)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2012-05-07 09:35:02.237
!MESSAGE Timed out while retrieving the attached javadoc for Canvas [in Canvas.class [in java.awt [in C:\Program Files\Java\jre7\lib\rt.jar]]] 

!ENTRY org.eclipse.jdt.core 4 4 2012-05-07 09:35:02.394
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;

import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.event.*;
import java.nio.FloatBuffer;
import java.util.HashMap;
import java.util.Map;
import javax.media.opengl.GL;
import javax.media.opengl.GL2;
import javax.media.opengl.awt.GLCanvas;
import echoesEngine.ListenerManager;
import utils.Interfaces.*;

public class EchoesGLCanvas extends GLCanvas
{   
  public static EchoesGLCanvas theCanvas;
  private float scaleBias = 1;
  private float tracking = 1;
  private float[] cameraPos = {100, 100, 100};
  private float orthoCoordWidth = 10;
  private float orthoCoordDepth = 100;
  private float aspectRatio = 1;
  private boolean aspectFourByThree = true;
  private boolean dragging = false;                            
  private float[] clear_colour = {0,0,0,0};      
  private Object currentScene = null;
  private int sceneElementCount = 0;
  private Map<String, Object> sceneElements = new HashMap<String, Object>();
  private Integer objectCount = 0;
  private Map<String, Object> objects = new HashMap<String, Object>();
  private Integer agentCount = 0;
  private Map<String, Object> agents = new HashMap<String, Object>();
  private Map<String, Object> drag = new HashMap<String, Object>();     //id's of drag events on objects 
  private Map<String, Object> bgtouch = new HashMap<String, Object>();   //id's of drag events on background  
  private float[] userList;          
  private Map<String, Object> agentActions =new HashMap<String, Object>(); 
  //private float actionLock = thread.allocate_lock(;)
  private Map<String, Object> piavcaAvatars = new HashMap<String, Object>();       
  private boolean touchEnabled = false;
  private Annotator annotator = null;           
  private String scenario = "";
  private boolean publishScore = true;
  private float targetLightLevel  = (float)0.8;
  private float lightLevel = (float)0.8;
  private Frame frame;    
  private int frameCounter = 0;
  private boolean printFPS = false;
  private boolean renderPiavca = false;
  private GL2 gl;
  private IRenderingListener rlPublisher;
  private IAgentListener agentPublisher;
  private int[] attribList = {GL.GL_RGBA, GL2.GL_DOUBLEBUFFER, 24}; 
  
  public void EchoesGLCanvas(Frame parent)
  {
    super(parent, -1, attribList);
    
    frame = parent;
    rlPublisher = (IRenderingListener)ListenerManager.GetInstance();
    agentPublisher = (IAgentListener)ListenerManager.GetInstance();
   
    /*
    Bind(EVT_ERASE_BACKGROUND,OnEraseBackground)
    Bind(wx.EVT_SIZE,OnSize)
    Bind(wx.EVT_PAINT,OnPaint)
    Bind(wx.EVT_LEFT_DOWN,OnMouseDown)
    Bind(wx.EVT_LEFT_UP,OnMouseUp)
    Bind(wx.EVT_LEFT_DCLICK,OnMouseDoubleClick)
    Bind(wx.EVT_RIGHT_DOWN,OnMouseDown)
    Bind(wx.EVT_RIGHT_UP,OnMouseUp)
    Bind(wx.EVT_MIDDLE_DOWN,OnMouseDown)
    Bind(wx.EVT_MIDDLE_UP,OnMouseUp)
    Bind(wx.EVT_MOTION,OnMouseMotion)
    Bind(wx.EVT_CHAR,OnKeyboard)
    Bind(wx.EVT_IDLE,OnIdle)
      
     // Listen for the events from the touch-server too
    Bind(EVT_ECHOES_CLICK_EVENT,OnEchoesClick)
    Bind(EVT_ECHOES_POINT_DOWN_EVENT,OnEchoesPointDown)
    Bind(EVT_ECHOES_POINT_MOVED_EVENT,OnEchoesPointMoved)
    Bind(EVT_ECHOES_POINT_UP_EVENT,OnEchoesPointUp)
      
    Bind(EVT_CREATE_PIAVCA_AVATAR,OnCreatePiavcaAvatar)
    Bind(EVT_LOAD_SCENARIO,OnLoadScenario)
    Bind(EVT_END_SCENARIO,OnEndScenario)
    Bind(EVT_ADD_OBJECT,OnAddObject)
    Bind(EVT_SET_OBJECT_PROPERTY,OnSetObjectProperty)
    Bind(EVT_REMOVE_OBJECT,OnRemoveObject)
    Bind(EVT_START_ANNOTATOR,OnStartAnnotator)
    Bind(EVT_STOP_ANNOTATOR,OnStopAnnotator)
    Bind(EVT_ANNOTATOR_DRAWING,OnAnnotatorDrawing)
    Bind(EVT_ANNOTATOR_NO_DRAWING,OnAnnotatorNoDrawing)
     */
    InitGL();
  }
  
  public void setCurrent()
  {
    //if (this.GetContext())
    //  SetCurrent();                
  }
        
  public void setClearColour(float r, float g, float b, float a)
  {
    //clear_colour = (r,g,b,a);
  }

  public void OnEraseBackground(PaintEvent event)
  {
      // Do nothing, to avoid flashing.
  }
  
  public void projection()
  {
//    gl.gluPerspective( 45.0,aspectRatio, 0.5, 50.0 ); 
      gl.glOrtho(-orthoCoordWidth/2,orthoCoordWidth/2, 
          -orthoCoordWidth/2/aspectRatio, orthoCoordWidth/2/aspectRatio, 
          -orthoCoordDepth/2, orthoCoordDepth/2);
  }
        
  public void OnSize(Event event)
  {
    Dimension size = getSize();
    int width = (size.width >= 0) ? size.width : 0;
    int height = (size.height >= 0) ? size.height : 0;
    if (getContext() != null)
    {
      setCurrent();
      gl.glViewport(0, 0, width, height);
      if (width > 0 && height > 0)
      {
        aspectRatio = (float)(width/height);
        if (aspectFourByThree)
           aspectRatio =aspectRatio * 4/3;
        //Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
        gl.glMatrixMode(GL2.GL_PROJECTION);
        gl.glLoadIdentity();
        projection();
      }
    }
    event.Skip();
  }
  
  public float[] getRegionCoords(String key)
  {
    float w = orthoCoordWidth;
    float h = orthoCoordWidth /aspectRatio;
    float d = orthoCoordDepth;
 
    if ("all" == key) return {(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)};
    if ("all80" == key) return {(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)}; 
    if ("all70" == key) return {(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)}; 
    if ("all60" == key) return {(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)}; 
    if ("all50" == key) return {(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)}; 
    if ("left" == key) return {(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)};
    if ("middle" == key) return {(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)};
    if ("right" == key) return {(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)};
    if ("v-top" == key) return {(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)}; 
    if ("v-middle" == key) return {(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)};
    if ("v-bottom" == key) return {(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)};
    /*
    if ("3x3" == key) return {{(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)}        // top-left
            {(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)},           // top-middle
            {(w/6, h/6, -1*d/2), (w/2, h/2, d/2)},              // top-right
            {(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)},     // middle-left
            {(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)},        // middle-middle
            {(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)},           // middle-right
            {(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)},  // bottom-left
            {(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)},     // bottom-middle
            {(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)}};         // bottom-right        */
    if ("ground" == key) return {(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)};
    if ("middle-ground" == key) return {(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)};
    if ("sky" == key) return {(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)};        
  }
            
  public void get3x3Neighbours(float [] region, float distance)
  {/*
    if (distance == 0)
        return region
    else
        return {{{1,4,3}, {2,5,8,7,6}},
                {{0,2,3,4,5}, {6,7,8}},
                {{1,4,5}, {0,3,6,7,8}},
                {{0,1,4,7,6}, {2,5,8}},
                {{0,1,2,3,5,6,7,8}, {}},
                {{1,2,4,7,8}, {0,3,6}},
                {{3,4,7}, {0,1,2,5,8}},
                {{6,3,4,5,8}, {0,1,2}},
                {{7,4,5}, {0,1,2,3,6}}}     */     
    

  @Override
  public void paint(Graphics g)
  {
    setCurrent();
    OnDraw();
  }

    public void OnMouseDown(MouseEvent event)
    {
      int x;
      int y;
      //y = event.GetPosition();

      if (!this.touchEnabled)
      {
        if (annotator != null)
           annotator.startDrag(x, y);
        else
        {
          int id = getObjectAtPosition(x, y);
          event.id = 0;
          if (id > -1)
          {
             drag[event.id] = id;
             objects[id].startDrag(x, y);
          }
        }
      }
    }
    
    public void OnMouseUp(MouseEvent event)
    {
     dragging = false;
      
      if (!touchEnabled)
      {
        if (Annotator != null)
           Annotator.stopDrag();
        else
        {
          if (drag.containsKey(event.id) && objects.containsKey(drag[event.id]))
          {
            if (this.objects[this.drag[event.id]].locationChanged)
               agentPublisher.agentActionCompleted("User", "drag", drag[event.id].toString());
            objects[drag[event.id]].stopDrag();
          }
          if (drag.containskey(event.id))
              drag.remove(event.id);
        }
      }
    }
    
    public void OnMouseMotion(Event event)
    {
      if (event.Dragging())
      {
        int x;
        int y;
        //y = event.GetPosition();

        Refresh(false);
        
        if (!touchEnabled)
        {
          if (this.Annotator
             Annotator.drag((x,y))
          else
          {
            event.id = 0;
            if (drag.containsKey(event.id)  && objects.containsKey(drag[event.id])
               objects[drag[event.id]].drag([x, y]);
          }
        }
      }
    }
    
    public void OnMouseDoubleClick(Event event)
    {
       int x, y = event.GetPosition();
       processClick(x, y);
    }
                
    public void processClick(int x, int y)
    {
      if (this.Annotator
         Annotator.click(x,y);
      else
      {
        id = getObjectAtPosition(x, y)
        if (id > -1)
        {
           objects[id].click("User");
           rlPublisher.userTouchedObject(str(id));
        }
        else
        {
          int id  = getAgentAtPosition(x,y);
          if (id > -1)
          {
             agents[id].click(this.getWorldCoord((x,y,0)));
             rlPublisher.userTouchedAgent(str(id));
          }
        }
        //menus =getMenus()
        //for menu in menus
        //    menu.click(this.getWorldCoord((x,y,0)));
      }
    }
        
    public void OnEchoesClick(Event event)
    {
      //Logger.trace("info",  "Click from ECHOES x = " + str(event.x) + "; y = " + str(event.y))
      int[] framePos = ScreenToClient(event.x, event.y);
      //Logger.trace("info",  "Location on screen " + str(framePos))
      processClick(framePos[0], framePos[1]);
    }

    public void OnEchoesPointDown(Event event)
    {
      Logger.trace("info",  "Point down from ECHOES id = " + str(event.id) + "; x = " + str(event.x) + "; y = " + str(event.y))
      framePos =ScreenToClient([event.x, event.y])
      Logger.trace("info",  "Location on screen " + str(framePos))
      if (this.Annotator != null)
         Annotator.startDrag(framePos)
      else
      {
        int id = getObjectAtPosition(framePos[0], framePos[1]);
        if (id > -1)
        {
          //Logger.trace("info",  "Touching object " + str(id) + " with gesture //" + str(event.id))
          rlPublisher.userTouchedObject(id.toString());
          drag[event.id] = id;
          objects[id].startDrag(framePos);
        }
        else
        {
          bgtouch[event.id] = framePos;
          agentPublisher.agentActionStarted("User", "touch_background", {framePos[0].toString(), framePos[1].toString()});
        }
      }
    }
    
    public void OnEchoesPointMoved(Event event)
    {
      int[] framePos = ScreenToClient(event.x, event.y);
      if (this.Annotator != null)
         Annotator.drag(framePos);
      else
      {
        if (event.id indrag anddrag[event.id] inobjects)
          objects[this.drag[event.id]].drag(framePos);
      }
    }
        
    public void OnEchoesPointUp(Event event)
    {
      Logger.trace("info",  "Point up from ECHOES id = " + str(event.id))
      if (this.Annotator
         Annotator.stopDrag()
      else        
      {
        if (event.id indrag anddrag[event.id] inobjects)
        {
          if (this.objects[this.drag[event.id]].locationChanged)
            agentPublisher.agentActionCompleted("User", "drag", {drag[event.id].toString()});
          objects[this.drag[event.id]].stopDrag();
        }
        if (event.id indrag)
            deldrag[event.id]
        if (event.id inbgtouch)
        {
           agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[event.id][0]), str(this.bgtouch[event.id][1])])
           delbgtouch[event.id];
        }
      }
    }
        
    public void OnKeyboard(Event event)
    {
      char c = event.KeyCode();
      
      if (char == 'f')
         app.fullscreen(notapp.fullscreenFlag)
      if (char == 'a')
      {
        removed = false;
        for (id, object in sceneElements.items())
        {
          if (isinstance(object, environment.HelperElements.Axis)
          {
            object.remove();
            removed = true;
          }
        }
      }                 
      if (char == 'g')
      {
        removed = false;
        for (id, object in sceneElements.items())
        {
          if (isinstance(object, environment.HelperElements.Grid3x3)
          {
            object.remove();
            removed = true;
          }
        }
        if (!removed)
          environment.HelperElements.Grid3x3(this.app);     
      }
    }
        
    public void OnCreatePiavcaAvatar(Event event)
    {
      if (event.type in piavcaAvatars)
      {
         piavcaAvatars[event.type].id = addAgent(this.piavcaAvatars[event.type], null);
         piavcaAvatars[event.type].startPostion();
         if (hasattr(evt, "pose"))
           piavcaAvatars[event.type].lookAtPoint(0, 3, 0);
         rlPublisher.agentAdded(str(this.agentCount), null);
      }
      else
      {
        // Create and auto-add the avatar
        if (event.type == "Paul")
           piavcaAvatars[event.type] = agents.PiavcaAvatars.Paul(event.autoadd, event.callback);
        else if (event.type == "Andy")
           piavcaAvatars[event.type] = agents.PiavcaAvatars.Andy(event.autoadd, event.callback);
        else
        {
          Logger.warning("Unknown avatar type " + event.name);
        }
      }
    }
        
    public void OnLoadScenario(Event event)
    {
      scenario = event.name;
      if (event.name == "Intro")
      {
        renderPiavca = false;
        environment.Backgrounds.Sky(this.app);
        bubble = objects.Bubbles.EchoesBubble(true, fadeIn=true);
        bubble.colour = "green";
        m =getRegionCoords("middle");
        bubble.setStartPos((m[0][0], 0,0));
        bubble.interactive = false;
        bubble.moving = false;
        bubble.size = 0.6  ;              
          //environment.Menu.UserMenu(true, true, userlist, pos=(0,0,0));  
      }
      else if (event.name == "BubbleWorld")
      {
         renderPiavca = false;
         score = 0;
         environment.Backgrounds.Sky(true, true);
      }
      else if ("Garden" in event.name)
      {
         bg = environment.Backgrounds.Garden(true);
         renderPiavca = true;
         score = 0;
         if (event.name == "GardenTask")
           bg.setImage("visual/images/GardenBackTask.png");
         else if (event.name == "GardenSocialGame")
           bg.setImage("visual/images/GardenBackSocialGame.png");
         else if (event.name == "GardenVeg")
           bg.setImage("visual/images/VegBackground.png");
      }
                
       currentScene = event.name;
       rlPublisher.scenarioStarted(event.name);
    }
        
    public void OnEndScenario(Event event)
    {
       scenario = "";
       if (event.name == "Intro" || event.name == "BubbleWorld" ||  event.name.contains("Garden"))
       {
          // Introduce a new transition bubble except in the Intro scene
          trans_bubble = null;
          if (event.name == "Intro")
          {
              for (id,object in objects.items())
              {
                if (object is objects.Bubbles.EchoesBubble)
                {
                  trans_bubble=object;
                  break;
                }
              }
              for (id, object in sceneElements.items())
              {
                if (isinstance(object, environment.Menu.UserMenu)
                  object.remove(false);
              }
          }
                                      
          if (not trans_bubble)
          {
              trans_bubble = objects.Bubbles.EchoesBubble(true, fadeIn=true, fadingFrames=100)
              trans_bubble.setStartPos((0,0,0))
          }
          trans_bubble.interactive = false
          trans_bubble.colour = "red"
          trans_bubble.moving = true
          trans_bubble.setTargetPos((this.orthoCoordWidth,orthoCoordWidth /aspectRatio,orthoCoordDepth))
          trans_bubble.removeAtTargetPos = true
          trans_bubble.removeAction = "PublishScenarioEnded"
          trans_bubble.callback = event.callback
          trans_bubble.removeActionArgs = event.name                                
       }
            
       renderPiavca = false;
       currentScene = null;
    }
        
    public void OnAddObject(Event event)
    {
      if (event.type == "Flower")
        objects.Plants.EchoesFlower(true, false, event.callback);
      else if (event.type == "Bubble")
        objects.Bubbles.EchoesBubble(true, true, event.callback);
      else if (event.type == "Ball")
        objects.PlayObjects.Ball(true, true, event.callback);
      else if (event.type == "IntroBubble")
      {
        EchoesBubble b = objects.Bubbles.EchoesBubble(true, true, event.callback);
        b.colour = "green";
        if (this.currentScene == "BubbleWorld")
            b.willBeReplaced = true;
        else
            b.willBeReplaced = false;
        b.setStartPos((0,5,0.5));
      }
      else if (event.type == "Pot")
        objects.Plants.Pot(true, true, event.callback);
      else if (event.type == "Ball")
        objects.PlayObjects.Ball(true, true, event.callback);
      else if (event.type == "Pond")
        objects.Environment.Pond(true, true, event.callback);
      else if (event.type == "Cloud")
        objects.Environment.Cloud(true, true, event.callback);
      else if (event.type == "Container")
        objects.Environment.Container(true, true, event.callback);
      else if (event.type == "Sun")
        objects.Environment.Sun(true, true, event.callback);
      else if (event.type == "LifeTree")
        objects.Plants.LifeTree(true, true, event.callback);
      else if (event.type == "MagicLeaves")
        objects.Plants.MagicLeaves(true, true, event.callback);
      else if (event.type == "Basket")
        objects.Environment.Basket(true, true, event.callback);
      else if (event.type == "Shed")
        objects.Environment.Shed(true, true, event.callback);
    }
        
    public void OnSetObjectProperty(Event event)
    {/*
        if (int(event.objId) inapp.canvas.objects
            o =app.canvas.objects[int(event.objId)]
            // Generic properties
            if (event.propName == "Pos"
                pos = str(event.propValue)
                if (pos.startswith("(") pos = pos[1]
                if (pos.endswith(")") pos = pos[-1]
                pos = pos.split(",")
                try
                    x = float(pos[0])
                except ValueError
                    Logger.warning("setObjectProperty Invalid coordinate for x")
                    return
                try
                    y = float(pos[1])
                except ValueError
                    try
                        f =getRegionCoords(pos[1].strip())
                        y = f[1][1]
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for y")
                        return
                try
                    z = float(pos[2])
                except ValueError
                    if (pos[2] == "front" z = 1
                    else if (pos[2] == "back" z = -1
                    else z = 0

                o.pos = [x,y,z]
            
            if (event.propName == "Size" and hasattr(o, "size")
                o.size = float(event.propValue)                
            
            if (event.propName == "Colour" and hasattr(o, "colour")
                o.colour = str(event.propValue)
                
            if (event.propName == "Interactive"
                o.interactive = (event.propValue == "true")
                        
            //Properties for Bubbles exposed to API
            if (isinstance(o, objects.Bubbles.EchoesBubble)
                if (event.propName == "Size" 
                    if (event.propValue == "Bigger"
                        o.grow()
                else if (event.propName == "Replace" 
                    o.willBeReplaced = (event.propValue == "true")
            //Properties for Flowers exposed to API    
            else if (isinstance(o, objects.Plants.EchoesFlower)
                if (event.propName == "MoveToBasket"
                    try 
                        id = int(event.propValue)
                    except 
                        id = None 
                    o.moveToBasket(id)
                else if (event.propName == "IntoBubble"
                    o.intoBubble()
                else if (event.propName == "IntoBall"
                    o.intoBall()
                else if (event.propName == "CanTurnIntoBall" 
                    o.canTurnIntoBall = (event.propValue == "true")
                else if (event.propName == "CanTurnIntoBubble" 
                    o.canTurnIntoBubble = (event.propValue == "true")
                else if (event.propName == "ChildCanTurnIntoBall" 
                    o.childCanTurnIntoBall = (event.propValue == "true")
                else if (event.propName == "ChildCanTurnIntoBubble" 
                    o.childCanTurnIntoBubble = (event.propValue == "true")
                else if (event.propName == "GrowToSize" 
                    if (event.propValue == "Max"
                        o.growToSize = o.maxSize
                    else
                         o.growToSize = float(event.propValue)
            //Properties for Pots exposed to API
            else if (isinstance(o, objects.Plants.Pot)
                if (event.propName == "GrowFlower"
                    o.growFlower()
                if (event.propName == "StackIntoTree" and o.stack
                    o.stack.intoTree()
            //Properties for Stacks exposed to API
            else if (isinstance(o, objects.Plants.Stack)
                if (event.propName == "StackIntoTree"
                    o.intoTree()
            //Properties for Ball exposed to API    
            else if (isinstance(o, objects.PlayObjects.Ball)
                if (event.propName == "BounceWithinScene"
                    o.bounceWithinScene = (event.propValue == "true")
                if (event.propName == "ChildCanChangeColour"
                    o.childCanChangeColour = (event.propValue == "true")
            //Properties for Container exposed to API    
            else if (isinstance(o, objects.Environment.Container)
                if (event.propName == "Reward"
                    o.reward(event.propValue)
            //Properties for Basket exposed to API    
            else if (isinstance(o, objects.Environment.Basket)
                if (event.propName == "PlayFanfare"
                    o.playFanfare()
            //Properties for Cloud exposed to API    
            else if (isinstance(o, objects.Environment.Cloud)
                if (event.propName == "CanRain"
                    o.canRain = (event.propValue == "true")
        else
            Logger.warning("setObjectProperty was called with object which is not in the objects list")*/
    }
                
    public void OnRemoveObject(Event event)
    {
      if (int(event.objId) in app.canvas.objects)
      {
          o =app.canvas.objects[int(event.objId)]
          o.remove();
      }
    }
    
    public void OnStartAnnotator(Event event)
    {
      if (null == Annotator)
         Annotator = Annotator.Annotator();
    }
        
    public void OnStopAnnotator(Event event)
    {
      if (Annotator != null)
      {
         Annotator.done();
         Annotator = null;
      }
    }
      
    public void OnAnnotatorDrawing(Event event)
    {
      if (Annotator != null)
         Annotator.drawingFeature(true);
    }
        
    public void OnAnnotatorNoDrawing(Event event)
    {
      if (Annotator != null)
         Annotator.drawingFeature(false);
    }
        
    public void OnDraw()
    {
     draw();
    }
    
    public void OnIdle(Event event)
    {
      draw();
      event.RequestMore();
    }

    public void InitGL()
    {
      gl.glMatrixMode(GL2.GL_MODELVIEW);
      gl.glClearDepth(1.0);
      
      gl.glEnable(GL2.GL_DEPTH_TEST);
      gl.glEnable(GL2.GL_NORMALIZE);

      gl.glEnable(GL2.GL_COLOR_MATERIAL);
      gl.glEnable(GL2.GL_BLEND);
      gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA);

      gl.glShadeModel(GL2.GL_SMOOTH);
      gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST);
      gl.glEnable(GL2.GL_LINE_SMOOTH);

      gl.glEnable(GL2.GL_LIGHTING);
      gl.glEnable(GL2.GL_LIGHT0);

      setLight(0.8);
      targetLightLevel = 0.8;
                    
      lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE);
    }
                                               
    public void setLight(float brightness)
    {
       lightLevel = brightness;
         
       // Create light components
       float al = brightness;
       float dl = max(0, brightness-0.2);
       float sl = max(0, brightness-0.8);
       ambientLight = [ al, al, al, 1.0 ];
       diffuseLight = [ dl, dl, dl, 1.0 ];
       specularLight = [ sl, sl, sl, 1.0 ];
         
       // Assign created components to GL2.GL_LIGHT0
       gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight);
       gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight);
       gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight);
    }
               
    public void clearScene(boolean quick)
    {
      if (hasattr("background") andbackground
         background.remove();
      for (id,object in sceneElements.items())
        object.remove(!quick);
      for(id,object in objects.items())
      {
        object.interactive = false;
        object.remove(!quick);
      }
    }
    
    public void draw()
    {
      if (this.printFPS)
      {
         frameCounter += 1
        if (time.time() -last_time >= 1)
        {
           float current_fps = frameCounter / (time.time() -last_time);
            //print current_fps, 'fps'
           frameCounter = 0;
           last_time = time.time();
        }
      }
      if (this.targetLightLevel != lightLevel)
      {
         float newlight = lightLevel + (this.targetLightLevel -lightLevel)/100;
         if (Math.abs(newlight-this.targetLightLevel) < 0.01)
           newlight = targetLightLevel);
         setLight(newlight);
      }

      // clear color and depth buffers
      gl.glClearColor(this.clear_colour[0],clear_colour[1],clear_colour[2],clear_colour[3]);
      gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT);
      
      gl.glMatrixMode(GL2.GL_MODELVIEW);
      gl.glLoadIdentity();
      gl.gluLookAt (this.cameraPos[0],cameraPos[1],cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

      // position of the light needs to be set after the projection
      gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ]);
      
     renderBackground ();
     renderEnvironment();          
     renderObjects();
     renderAgents();

      if (this.renderPiavca)
      {
        Piavca.Core.getCore().timeStep(); 
        Piavca.Core.getCore().prerender();
        Piavca.Core.getCore().render();
      }
      
      if (this.Annotator)
       Annotator.render();

      SwapBuffers();
    }
        
    public void addBackground(Object object)
    {
       background = object;
    }
            
    public void renderBackground()
    {
      if (hasattr("background") andbackground && hasattr(this.background, "render"))
         background.render();
    }
                
    public void removeBackground()
    {
       background = null;
    }

    public void addSceneElement(Object object)
    {
      sceneElementCount =sceneElementCount + 1;
      sceneElements[this.sceneElementCount] = object;
      returnsceneElementCount;
    }
            
    public void removeSceneElement(String id)
    {
      sceneElements.remove(id);
    }

    public void renderEnvironment()
    {
      for (String id : sceneElements.keys())
      {
        Object object = sceneElements[id];
        if (hasattr(object, "render"))
        {
            gl.glPushName (int(id));
            object.render();
            gl.glPopName ();
        }
      }
    }
    
    public void getMenus()
    {/*
        menus = []
        for id, object insceneElements.items()
            if (isinstance(object, environment.Menu.UserMenu)
                menus.append(object)
        return menus;*/
    }
        
    public int addObject(Object object, Map<String, String> props)
    {
       objectCount++;
       objects.put(objectCount.toString(), object);
       rlPublisher.objectAdded(objectCount.toString(), props);
       return objectCount;
    }
        
    public void removeObject(String id)
    {
       objects.remove(id);
       rlPublisher.objectRemoved(id);
    }

    public void renderObjects(boolean hitTest)
    {
      for (String id : objects.keySet())
      {
        Object object = objects.get(id);
        if (hasAttr(object, "render"))
        {
          gl.glPushName (Integer.parseInt(id));
          object.render(hitTest);
          gl.glPopName ();
        }
      }
      
        //objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true,objects.iteritems()))
        //collisions = hitTest(objectsToTest)               
        //for (pair in collisions)                
        //  objectCollision(pair[0], pair[1],app);
    }
    
    public int addAgent(Object agent, Map<String, String> props)
    {
      //renderPiavca = true
      agentCount++;
      agents.put(agentCount.toString(), agent);
      rlPublisher.agentAdded(agentCount.toString(), agent.props);
      return agentCount;
    }
        
    public void removeAgent(String id)
    {
      agents.remove(id);
      // if (len(this.agents) == 0
          //renderPiavca = false
      rlPublisher.agentRemoved(id);
    }
            
    public void renderAgents()
    {
        for id inagents.keys()
            agent =agents[id]
            if (hasattr(agent, "render")
                gl.glPushName (int(id))
                agent.render()
                gl.glPopName ()
        
        objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true,objects.iteritems()))
        agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true,agents.iteritems()))
        collisions =agentHitTest(agentsToTest, objectsToTest)       
                        
        for pair in collisions                 
            agentObjectCollision(pair[0], pair[1],app)
    }

    /*
    public void agentActionStarted(Object callback, String unique_actionid, String agentId, action, details)
    {
       actionLock.acquire()
        // pass
        Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
        if (hasattr("agentPublisher")
           agentPublisher.agentActionStarted(agentId, action, details)

       agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
       actionLock.release()
    }
    
    public void agentActionCompleted(String unique_actionid, boolean success)
    {
       actionLock.acquire()
        // pass
        Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
        if (hasattr("agentPublisher") and unique_actionid inagentActions
            // if (this.agentActions[unique_actionid].callback
                // Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                //agentActions[unique_actionid].callback.ice_response(success)
            try
                if (success
                   agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId,agentActions[unique_actionid].action,agentActions[unique_actionid].details)
                else
                   agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId,agentActions[unique_actionid].action,agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
            except
                Logger.warning("Incomplete information in completed agent action")
            delagentActions[unique_actionid]
        else
            Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
       actionLock.release();
    }
    */
    
    public void getObjectIds()
    {
      return objects.keySet();
    }
            
    public Object getObjectAtPosition(int x, int y)
    {
        Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

        // Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
        
        // Get the current viewport
        viewport = glGetIntegerv(GL2.GL_VIEWPORT);
        
        // Prepare a buffer to hold the results
        gl.glSelectBuffer (100);

        // Put OpenGL into selection mode, and reset the name stack
        gl.glRenderMode(GL2.GL_SELECT);
        gl.glInitNames();
        
        // Only draw in the area under the mouse click
        gl.glMatrixMode(GL2.GL_PROJECTION);
        gl.glPushMatrix();
        gl.glLoadIdentity();
        gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport);
        
        // Multiply the perspective matrix by the pick matrix to restrict the drawing area
       projection();
        
        // Switch to normal mode, render the target to the buffer, and do some further mapping
        gl.glMatrixMode(GL2.GL_MODELVIEW);
       renderObjects(true);
        gl.glMatrixMode(GL2.GL_PROJECTION);
        gl.glPopMatrix();;
        gl.glMatrixMode(GL2.GL_MODELVIEW)

        // Switch back to normal mode and see whether we hit anything
        records = glRenderMode(GL2.GL_RENDER);
        hitObject = -1;
        // Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
//            if (len(records) > 0
//                hitObject = records[len(records)-1].names[0]
//                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
//                    hitObject = records[len(records)-2].names[0]
        distance = 1000;
        for ( record in records)
        {
            if (record.near < distance)
            {
                distance = record.near;
                hitObject = record.names[0];
            }
        }
                
        return hitObject;
    }
        
    public String getAgentAtPosition(int x, int y)
    {/*
        Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
        rx, ry, rz =getWorldCoord((x,y))
        for id inagents.keys()
            agent =agents[id]
            if (hasattr(agent, "avatar")
                c = agent.getXYContour()
                if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                    return id */
        return "";
    }
        
    public void getScreenCoord(float[] pos)
    {
      int[] viewport = new int[4];
      double[] modelview = new double[16];
      double[] projection = new double[16];
      
      glGetDoublev(GL2.GL_MODELVIEW_MATRIX, modelview, 0);
      glGetDoublev(GL2.GL_PROJECTION_MATRIX, projection, 0);
      glGetIntegerv(GL2.GL_VIEWPORT, viewport, 0);

     // return gluProject(pos[0], pos[1], pos[2], model, projection, viewport);
    }
                    
    public void getWorldCoord(float[] pos)
    {
      int[] viewport = new int[4];
      double[] modelview = new double[16];
      double[] projection = new double[16];
      
      glGetDoublev(GL2.GL_MODELVIEW_MATRIX, modelview, 0);
      glGetDoublev(GL2.GL_PROJECTION_MATRIX, projection, 0);
      glGetIntegerv(GL2.GL_VIEWPORT, viewport, 0);
      
      //wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
      //unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport);;
      //return unprojected;
    }

    public void drawBezier(float[] ctrlPoints, boolean drawPoints, int numStrips)
    {
      gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints);
      gl.glEnable(GL2.GL_MAP1_VERTEX_3);
      gl.glBegin(GL2.GL_LINE_STRIP);
      for (int i = 0; i < numStrips; i++)
          gl.glEvalCoord1f((float)i/numStrips);
      gl.glEnd();
      if (drawPoints)
      {
        gl.glPointSize(5.0);
        gl.glColor3f(1.0, 1.0, 0.0);
        gl.glBegin(GL2.GL_POINTS);
        for (point in ctrlPoints )
            gl.glVertex3fv(point);
        gl.glEnd();
      }
    }     
                
    public Map<Object, Object> hitTest(Map<String, Object> things, Map<String, Object> otherThings)
    {
      Map<Object, Object> collisions= new HashMap<Object, Object>();
      if (null == otherThings)
      {
        for (String id1 : things.keySet())
        {
          for (String id2 : things.keys())
          {
            if (id2 < id1)
                continue;
            if (id1 != id2)
            {
              Object o1 = things[id1];
              Object o2 = things[id2];
              float deltaX = o2.pos[0] - o1.pos[0];
              float deltaY = o2.pos[1] - o1.pos[1];
              float deltaZ = o2.pos[2] - o1.pos[2];
              if (isinstance(o1, objects.Plants.EchoesFlower) || isinstance(o2, objects.Plants.EchoesFlower))
              {
                if (isinstance(o1, objects.Plants.EchoesFlower))
                {
                  flower = o1;
                  other = o2;
                }
                else
                {
                  flower = o2;
                  other = o1;
                }
                deltaY = flower.pos[1] - other.pos[1];
                if (abs(deltaX) <= other.size && deltaY < (other.size + flower.stemLength) && deltaY > 0)
                  collisions.add(o1, o2);
              }
              else
              {
                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ;
                minDistance = o1.size + o2.size;
                if (distanceSquared < minDistance * minDistance)
                  collisions.add(o1,o2);
              }
            }
          }
        }
      }
      else
      {
        for (Object o1 : things)
        {
          for (Object o2 : otherThings)
          {
            deltaX = o2.pos[0] - o1.pos[0];
            deltaY = o2.pos[1] - o1.pos[1];
            deltaZ = o2.pos[2] - o1.pos[2];
            distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ;
            minDistance = o1.size + o2.size;
            if (distanceSquared < minDistance * minDistance)
                collisions.add(o1,o2);
          }
        }
      }
      return collisions;
    }
        
    public void agentHitTest(Map<String, Object> agentsToTest, Map<String, Object> objectsToTest)
    {/*
        noAvatars = dict()
        collisions = []
        for aid, agent in agentsToTest.items()
            if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                bb = agent.getXYContour()
                for oid, object in objectsToTest.items()
                    if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                        if (object.beingDragged object.draggedOverAgent = agent.id
                        else object.draggedOverAgent = None
                        object.overAgent = agent.id
                        collisions.append([agent, object])
                    else
                        object.draggedOverAgent = None
                        object.overAgent = None                            
            else
                noAvatars[aid] = agent
        if (len(noAvatars) > 0
            collisions +=hitTest(noAvatars, objectsToTest)
        return collisions      */                        
    }
        
  public void saveScreenshot(String name, String path)
  {/*
     // Read in the screen information in the area specified """
      gl.glFinish();
      gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4);
      gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0);
      gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0);
      gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0);

      data = glReadPixels(0, 0,size[0],size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE);
      
      if (null == name)
        name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M");
      if (null ==  path)
        path = os.getcwd();

      im = PIL.Image.fromstring("RGBA",size, data);
      im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG");*/
   }
}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:572)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-07 09:35:02.401
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:572)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-07 09:35:02.404
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:572)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 10001 2012-05-07 09:47:55.305
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for MouseEvent {key=Ljava/awt/event/MouseEvent;} [in MouseEvent.class [in java.awt.event [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryType.getAttachedJavadoc(BinaryType.java:995)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:462)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:621)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:567)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:559)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:142)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2012-05-07 09:47:55.305
!MESSAGE Timed out while retrieving the attached javadoc for MouseEvent {key=Ljava/awt/event/MouseEvent;} [in MouseEvent.class [in java.awt.event [in C:\Program Files\Java\jre7\lib\rt.jar]]] 

!ENTRY org.eclipse.jdt.core 4 4 2012-05-07 10:35:00.514
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;

import java.awt.AWTEvent;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.event.*;
import java.nio.FloatBuffer;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import javax.media.opengl.GL;
import javax.media.opengl.GL2;
import javax.media.opengl.awt.GLCanvas;
import echoesEngine.ListenerManager;
import utils.Interfaces.*;

public class EchoesGLCanvas extends GLCanvas
{   
  public static EchoesGLCanvas theCanvas;
  public float orthoCoordWidth = 10;
  public float orthoCoordDepth = 100;
  public float aspectRatio = 1;
  public String scenario = "";
  public float[] frameSize; 
  public boolean renderPiavca = false;
  public Map<String, Object> piavcaAvatars = new HashMap<String, Object>();     
  
  private float scaleBias = 1;
  private float tracking = 1;
  private float[] cameraPos = {100, 100, 100};
  private boolean aspectFourByThree = true;
  private boolean dragging = false;                            
  private float[] clear_colour = {0,0,0,0};      
  private Object currentScene = null;
  private int sceneElementCount = 0;
  private Map<String, Object> sceneElements = new HashMap<String, Object>();
  private Integer objectCount = 0;
  private Map<String, Object> objects = new HashMap<String, Object>();
  private Integer agentCount = 0;
  private Map<String, Object> agents = new HashMap<String, Object>();
  private Map<String, Object> drag = new HashMap<String, Object>();     //id's of drag events on objects 
  private Map<String, Object> bgtouch = new HashMap<String, Object>();   //id's of drag events on background  
  private float[] userList;          
  private Map<String, Object> agentActions =new HashMap<String, Object>(); 
  //private float actionLock = thread.allocate_lock(;)
  private boolean touchEnabled = false;
  private Annotator annotator = null;           
  private boolean publishScore = true;
  private float targetLightLevel  = (float)0.8;
  private float lightLevel = (float)0.8;
  private Frame frame;    
  private int frameCounter = 0;
  private boolean printFPS = false;
  
  private GL2 gl;
  private IRenderingListener rlPublisher;
  private IAgentListener agentPublisher;
  private  Graphics context;
  private int[] attribList = {GL.GL_RGBA, GL2.GL_DOUBLEBUFFER, 24};
  
  
  public void EchoesGLCanvas(Frame parent)
  {
    super(parent, -1, attribList);
    
    frame = parent;
    rlPublisher = (IRenderingListener)ListenerManager.GetInstance();
    agentPublisher = (IAgentListener)ListenerManager.GetInstance();
    
    enableEvents( AWTEvent.MOUSE_MOTION_EVENT_MASK | AWTEvent.MOUSE_EVENT_MASK |   AWTEvent.WINDOW_EVENT_MASK
        | AWTEvent.WINDOW_STATE_EVENT_MASK | AWTEvent.PAINT_EVENT_MASK  | AWTEvent.KEY_EVENT_MASK);   
   
    /*
    Bind(EVT_ERASE_BACKGROUND,OnEraseBackground)
    Bind(wx.EVT_SIZE,OnSize)
    Bind(wx.EVT_PAINT,OnPaint)
    Bind(wx.EVT_LEFT_DOWN,OnMouseDown)
    Bind(wx.EVT_LEFT_UP,OnMouseUp)
    Bind(wx.EVT_LEFT_DCLICK,OnMouseDoubleClick)
    Bind(wx.EVT_RIGHT_DOWN,OnMouseDown)
    Bind(wx.EVT_RIGHT_UP,OnMouseUp)
    Bind(wx.EVT_MIDDLE_DOWN,OnMouseDown)
    Bind(wx.EVT_MIDDLE_UP,OnMouseUp)
    Bind(wx.EVT_MOTION,OnMouseMotion)
    Bind(wx.EVT_CHAR,OnKeyboard)
    Bind(wx.EVT_IDLE,OnIdle)
      
     // Listen for the events from the touch-server too
    Bind(EVT_ECHOES_CLICK_EVENT,OnEchoesClick)
    Bind(EVT_ECHOES_POINT_DOWN_EVENT,OnEchoesPointDown)
    Bind(EVT_ECHOES_POINT_MOVED_EVENT,OnEchoesPointMoved)
    Bind(EVT_ECHOES_POINT_UP_EVENT,OnEchoesPointUp)
      
    Bind(EVT_CREATE_PIAVCA_AVATAR,OnCreatePiavcaAvatar)
    Bind(EVT_LOAD_SCENARIO,OnLoadScenario)
    Bind(EVT_END_SCENARIO,OnEndScenario)
    Bind(EVT_ADD_OBJECT,OnAddObject)
    Bind(EVT_SET_OBJECT_PROPERTY,OnSetObjectProperty)
    Bind(EVT_REMOVE_OBJECT,OnRemoveObject)
    Bind(EVT_START_ANNOTATOR,OnStartAnnotator)
    Bind(EVT_STOP_ANNOTATOR,OnStopAnnotator)
    Bind(EVT_ANNOTATOR_DRAWING,OnAnnotatorDrawing)
    Bind(EVT_ANNOTATOR_NO_DRAWING,OnAnnotatorNoDrawing)
     */
    InitGL();
  }
  
  public void addNotify() 
  { 
    super.addNotify();   
    context = this.getGraphics().create();
  } 
  
  public void setCurrent()
  {
    if (this.getContext() != null)
      setCurrent();                
  }
        
  public void setClearColour(float r, float g, float b, float a)
  {
    //clear_colour = (r,g,b,a);
  }
  
  public void projection()
  {
//    gl.gluPerspective( 45.0,aspectRatio, 0.5, 50.0 ); 
      gl.glOrtho(-orthoCoordWidth/2,orthoCoordWidth/2, 
          -orthoCoordWidth/2/aspectRatio, orthoCoordWidth/2/aspectRatio, 
          -orthoCoordDepth/2, orthoCoordDepth/2);
  }

  public void OnEraseBackground(PaintEvent event)
  {
      // Do nothing, to avoid flashing.
  }
        
  public void OnSize(Event event)
  {
    Dimension size = getSize();
    int width = (size.width >= 0) ? size.width : 0;
    int height = (size.height >= 0) ? size.height : 0;
    if (getContext() != null)
    {
      setCurrent();
      gl.glViewport(0, 0, width, height);
      if (width > 0 && height > 0)
      {
        aspectRatio = (float)(width/height);
        if (aspectFourByThree)
           aspectRatio =aspectRatio * 4/3;
        //Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
        gl.glMatrixMode(GL2.GL_PROJECTION);
        gl.glLoadIdentity();
        projection();
      }
    }
    event.Skip();
  }
  
  protected void processMouseEvent(MouseEvent event)
  {
    if (event.getID() == MouseEvent.MOUSE_PRESSED) 
      OnMouseDown(event);
    else if (event.getID() == MouseEvent.MOUSE_RELEASED) 
      OnMouseUp(event);
    //else if (event.getID() == MouseEvent.MOUSE_MOVED) 
   //   OnMouseMove(event);
  }
  
  protected void processMouseMotionEvent(MouseEvent event)
  {
    OnMouseMove(event);
  }
  
  public void OnMouseDown(MouseEvent event)
  {
    int x = event.getX();
    int y = event.getY();

    if (!this.touchEnabled)
    {
      if (annotator != null)
         annotator.startDrag(x, y);
      else
      {
        String id = getObjectAtPosition(x, y);
        if (id > -1)
        {
           drag[event.getID()] = id;
           objects[id].startDrag(x, y);
        }
      }
    }
  }

  public void OnMouseUp(MouseEvent event)
  {
   dragging = false;
    
    if (!touchEnabled)
    {
      if (annotator != null)
         annotator.stopDrag();
      else
      {
        if (drag.containsKey(event.id) && objects.containsKey(drag[event.id]))
        {
          if (this.objects[this.drag[event.id]].locationChanged)
             agentPublisher.agentActionCompleted("User", "drag", drag[event.id].toString());
          objects[drag[event.id]].stopDrag();
        }
        if (drag.containskey(event.id))
            drag.remove(event.id);
      }
    }
  }
  
  public void OnMouseMove(MouseEvent event)
  {
    if (event.Dragging())
    {
      int x;
      int y;
      //y = event.GetPosition();

      refresh(false);
      
      if (!touchEnabled)
      {
        if (this.Annotator != null)
           Annotator.drag((x,y))
        else
        {
          event.id = 0;
          if (drag.containsKey(event.id)  && objects.containsKey(drag[event.id])
             objects[drag[event.id]].drag([x, y]);
        }
      }
    }
  }
  
  public void OnMouseDoubleClick(Event event)
  {
     int x, y = event.GetPosition();
     processClick(x, y);
  }
              
  public void processClick(int x, int y)
  {
    if (this.Annotator
       Annotator.click(x,y);
    else
    {
      id = getObjectAtPosition(x, y)
      if (id > -1)
      {
         objects[id].click("User");
         rlPublisher.userTouchedObject(str(id));
      }
      else
      {
        int id  = getAgentAtPosition(x,y);
        if (id > -1)
        {
           agents[id].click(this.getWorldCoord((x,y,0)));
           rlPublisher.userTouchedAgent(str(id));
        }
      }
      //menus =getMenus()
      //for menu in menus
      //    menu.click(this.getWorldCoord((x,y,0)));
    }
  }
  
  public float[] getRegionCoords(String key)
  {
    float w = orthoCoordWidth;
    float h = orthoCoordWidth /aspectRatio;
    float d = orthoCoordDepth;
 
    if ("all" == key) return {(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)};
    if ("all80" == key) return {(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)}; 
    if ("all70" == key) return {(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)}; 
    if ("all60" == key) return {(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)}; 
    if ("all50" == key) return {(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)}; 
    if ("left" == key) return {(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)};
    if ("middle" == key) return {(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)};
    if ("right" == key) return {(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)};
    if ("v-top" == key) return {(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)}; 
    if ("v-middle" == key) return {(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)};
    if ("v-bottom" == key) return {(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)};
    /*
    if ("3x3" == key) return {{(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)}        // top-left
            {(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)},           // top-middle
            {(w/6, h/6, -1*d/2), (w/2, h/2, d/2)},              // top-right
            {(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)},     // middle-left
            {(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)},        // middle-middle
            {(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)},           // middle-right
            {(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)},  // bottom-left
            {(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)},     // bottom-middle
            {(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)}};         // bottom-right        */
    if ("ground" == key) return {(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)};
    if ("middle-ground" == key) return {(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)};
    if ("sky" == key) return {(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)};        
  }
            
  public void get3x3Neighbours(float [] region, float distance)
  {/*
    if (distance == 0)
        return region
    else
        return {{{1,4,3}, {2,5,8,7,6}},
                {{0,2,3,4,5}, {6,7,8}},
                {{1,4,5}, {0,3,6,7,8}},
                {{0,1,4,7,6}, {2,5,8}},
                {{0,1,2,3,5,6,7,8}, {}},
                {{1,2,4,7,8}, {0,3,6}},
                {{3,4,7}, {0,1,2,5,8}},
                {{6,3,4,5,8}, {0,1,2}},
                {{7,4,5}, {0,1,2,3,6}}}     */     
  }

  @Override
  public void paint(Graphics g)
  {
    setCurrent();
    OnDraw();
  }

  
      
  public void OnEchoesClick(Event event)
  {
    //Logger.trace("info",  "Click from ECHOES x = " + str(event.x) + "; y = " + str(event.y))
    int[] framePos = ScreenToClient(event.x, event.y);
    //Logger.trace("info",  "Location on screen " + str(framePos))
    processClick(framePos[0], framePos[1]);
  }

  public void OnEchoesPointDown(Event event)
  {
    Logger.trace("info",  "Point down from ECHOES id = " + str(event.id) + "; x = " + str(event.x) + "; y = " + str(event.y))
    framePos =ScreenToClient([event.x, event.y])
    Logger.trace("info",  "Location on screen " + str(framePos))
    if (this.Annotator != null)
       Annotator.startDrag(framePos)
    else
    {
      int id = getObjectAtPosition(framePos[0], framePos[1]);
      if (id > -1)
      {
        //Logger.trace("info",  "Touching object " + str(id) + " with gesture //" + str(event.id))
        rlPublisher.userTouchedObject(id.toString());
        drag[event.id] = id;
        objects[id].startDrag(framePos);
      }
      else
      {
        bgtouch[event.id] = framePos;
        agentPublisher.agentActionStarted("User", "touch_background", {framePos[0].toString(), framePos[1].toString()});
      }
    }
  }
  
  public void OnEchoesPointMoved(Event event)
  {
    int[] framePos = ScreenToClient(event.x, event.y);
    if (this.Annotator != null)
       Annotator.drag(framePos);
    else
    {
      if (event.id indrag anddrag[event.id] inobjects)
        objects[this.drag[event.id]].drag(framePos);
    }
  }
      
  public void OnEchoesPointUp(Event event)
  {
    Logger.trace("info",  "Point up from ECHOES id = " + str(event.id))
    if (this.Annotator
       Annotator.stopDrag()
    else        
    {
      if (event.id indrag anddrag[event.id] inobjects)
      {
        if (this.objects[this.drag[event.id]].locationChanged)
          agentPublisher.agentActionCompleted("User", "drag", {drag[event.id].toString()});
        objects[this.drag[event.id]].stopDrag();
      }
      if (event.id indrag)
          deldrag[event.id]
      if (event.id inbgtouch)
      {
         agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[event.id][0]), str(this.bgtouch[event.id][1])])
         delbgtouch[event.id];
      }
    }
  }
      
  public void OnKeyboard(Event event)
  {
    char c = event.KeyCode();
    
    if (char == 'f')
       app.fullscreen(notapp.fullscreenFlag)
    if (char == 'a')
    {
      removed = false;
      for (id, object in sceneElements.items())
      {
        if (isinstance(object, environment.HelperElements.Axis)
        {
          object.remove();
          removed = true;
        }
      }
    }                 
    if (char == 'g')
    {
      removed = false;
      for (id, object in sceneElements.items())
      {
        if (isinstance(object, environment.HelperElements.Grid3x3)
        {
          object.remove();
          removed = true;
        }
      }
      if (!removed)
        environment.HelperElements.Grid3x3(this.app);     
    }
  }
      
  public void OnCreatePiavcaAvatar(Event event)
  {
    if (event.type in piavcaAvatars)
    {
       piavcaAvatars[event.type].id = addAgent(this.piavcaAvatars[event.type], null);
       piavcaAvatars[event.type].startPostion();
       if (hasattr(evt, "pose"))
         piavcaAvatars[event.type].lookAtPoint(0, 3, 0);
       rlPublisher.agentAdded(str(this.agentCount), null);
    }
    else
    {
      // Create and auto-add the avatar
      if (event.type == "Paul")
         piavcaAvatars[event.type] = agents.PiavcaAvatars.Paul(event.autoadd, event.callback);
      else if (event.type == "Andy")
         piavcaAvatars[event.type] = agents.PiavcaAvatars.Andy(event.autoadd, event.callback);
      else
      {
        Logger.warning("Unknown avatar type " + event.name);
      }
    }
  }
      
  public void OnLoadScenario(Event event)
  {
    scenario = event.name;
    if (event.name == "Intro")
    {
      renderPiavca = false;
      environment.Backgrounds.Sky(this.app);
      bubble = objects.Bubbles.EchoesBubble(true, fadeIn=true);
      bubble.colour = "green";
      m =getRegionCoords("middle");
      bubble.setStartPos((m[0][0], 0,0));
      bubble.interactive = false;
      bubble.moving = false;
      bubble.size = 0.6  ;              
        //environment.Menu.UserMenu(true, true, userlist, pos=(0,0,0));  
    }
    else if (event.name == "BubbleWorld")
    {
       renderPiavca = false;
       score = 0;
       environment.Backgrounds.Sky(true, true);
    }
    else if ("Garden" in event.name)
    {
       bg = environment.Backgrounds.Garden(true);
       renderPiavca = true;
       score = 0;
       if (event.name == "GardenTask")
         bg.setImage("visual/images/GardenBackTask.png");
       else if (event.name == "GardenSocialGame")
         bg.setImage("visual/images/GardenBackSocialGame.png");
       else if (event.name == "GardenVeg")
         bg.setImage("visual/images/VegBackground.png");
    }
              
     currentScene = event.name;
     rlPublisher.scenarioStarted(event.name);
  }
      
  public void OnEndScenario(Event event)
  {
     scenario = "";
     if (event.name == "Intro" || event.name == "BubbleWorld" ||  event.name.contains("Garden"))
     {
        // Introduce a new transition bubble except in the Intro scene
        trans_bubble = null;
        if (event.name == "Intro")
        {
            for (id,object in objects.items())
            {
              if (object is objects.Bubbles.EchoesBubble)
              {
                trans_bubble=object;
                break;
              }
            }
            for (id, object in sceneElements.items())
            {
              if (isinstance(object, environment.Menu.UserMenu)
                object.remove(false);
            }
        }
                                    
        if (not trans_bubble)
        {
            trans_bubble = objects.Bubbles.EchoesBubble(true, fadeIn=true, fadingFrames=100)
            trans_bubble.setStartPos((0,0,0))
        }
        trans_bubble.interactive = false
        trans_bubble.colour = "red"
        trans_bubble.moving = true
        trans_bubble.setTargetPos((this.orthoCoordWidth,orthoCoordWidth /aspectRatio,orthoCoordDepth))
        trans_bubble.removeAtTargetPos = true
        trans_bubble.removeAction = "PublishScenarioEnded"
        trans_bubble.callback = event.callback
        trans_bubble.removeActionArgs = event.name                                
     }
          
     renderPiavca = false;
     currentScene = null;
  }
      
  public void OnAddObject(Event event)
  {
    if (event.type == "Flower")
      objects.Plants.EchoesFlower(true, false, event.callback);
    else if (event.type == "Bubble")
      objects.Bubbles.EchoesBubble(true, true, event.callback);
    else if (event.type == "Ball")
      objects.PlayObjects.Ball(true, true, event.callback);
    else if (event.type == "IntroBubble")
    {
      EchoesBubble b = objects.Bubbles.EchoesBubble(true, true, event.callback);
      b.colour = "green";
      if (this.currentScene == "BubbleWorld")
          b.willBeReplaced = true;
      else
          b.willBeReplaced = false;
      b.setStartPos((0,5,0.5));
    }
    else if (event.type == "Pot")
      objects.Plants.Pot(true, true, event.callback);
    else if (event.type == "Ball")
      objects.PlayObjects.Ball(true, true, event.callback);
    else if (event.type == "Pond")
      objects.Environment.Pond(true, true, event.callback);
    else if (event.type == "Cloud")
      objects.Environment.Cloud(true, true, event.callback);
    else if (event.type == "Container")
      objects.Environment.Container(true, true, event.callback);
    else if (event.type == "Sun")
      objects.Environment.Sun(true, true, event.callback);
    else if (event.type == "LifeTree")
      objects.Plants.LifeTree(true, true, event.callback);
    else if (event.type == "MagicLeaves")
      objects.Plants.MagicLeaves(true, true, event.callback);
    else if (event.type == "Basket")
      objects.Environment.Basket(true, true, event.callback);
    else if (event.type == "Shed")
      objects.Environment.Shed(true, true, event.callback);
  }
      
  public void OnSetObjectProperty(Event event)
  {/*
      if (int(event.objId) inapp.canvas.objects
          o =app.canvas.objects[int(event.objId)]
          // Generic properties
          if (event.propName == "Pos"
              pos = str(event.propValue)
              if (pos.startswith("(") pos = pos[1]
              if (pos.endswith(")") pos = pos[-1]
              pos = pos.split(",")
              try
                  x = float(pos[0])
              except ValueError
                  Logger.warning("setObjectProperty Invalid coordinate for x")
                  return
              try
                  y = float(pos[1])
              except ValueError
                  try
                      f =getRegionCoords(pos[1].strip())
                      y = f[1][1]
                  except ValueError
                      Logger.warning("setObjectProperty Invalid coordinate for y")
                      return
              try
                  z = float(pos[2])
              except ValueError
                  if (pos[2] == "front" z = 1
                  else if (pos[2] == "back" z = -1
                  else z = 0

              o.pos = [x,y,z]
          
          if (event.propName == "Size" and hasattr(o, "size")
              o.size = float(event.propValue)                
          
          if (event.propName == "Colour" and hasattr(o, "colour")
              o.colour = str(event.propValue)
              
          if (event.propName == "Interactive"
              o.interactive = (event.propValue == "true")
                      
          //Properties for Bubbles exposed to API
          if (isinstance(o, objects.Bubbles.EchoesBubble)
              if (event.propName == "Size" 
                  if (event.propValue == "Bigger"
                      o.grow()
              else if (event.propName == "Replace" 
                  o.willBeReplaced = (event.propValue == "true")
          //Properties for Flowers exposed to API    
          else if (isinstance(o, objects.Plants.EchoesFlower)
              if (event.propName == "MoveToBasket"
                  try 
                      id = int(event.propValue)
                  except 
                      id = None 
                  o.moveToBasket(id)
              else if (event.propName == "IntoBubble"
                  o.intoBubble()
              else if (event.propName == "IntoBall"
                  o.intoBall()
              else if (event.propName == "CanTurnIntoBall" 
                  o.canTurnIntoBall = (event.propValue == "true")
              else if (event.propName == "CanTurnIntoBubble" 
                  o.canTurnIntoBubble = (event.propValue == "true")
              else if (event.propName == "ChildCanTurnIntoBall" 
                  o.childCanTurnIntoBall = (event.propValue == "true")
              else if (event.propName == "ChildCanTurnIntoBubble" 
                  o.childCanTurnIntoBubble = (event.propValue == "true")
              else if (event.propName == "GrowToSize" 
                  if (event.propValue == "Max"
                      o.growToSize = o.maxSize
                  else
                       o.growToSize = float(event.propValue)
          //Properties for Pots exposed to API
          else if (isinstance(o, objects.Plants.Pot)
              if (event.propName == "GrowFlower"
                  o.growFlower()
              if (event.propName == "StackIntoTree" and o.stack
                  o.stack.intoTree()
          //Properties for Stacks exposed to API
          else if (isinstance(o, objects.Plants.Stack)
              if (event.propName == "StackIntoTree"
                  o.intoTree()
          //Properties for Ball exposed to API    
          else if (isinstance(o, objects.PlayObjects.Ball)
              if (event.propName == "BounceWithinScene"
                  o.bounceWithinScene = (event.propValue == "true")
              if (event.propName == "ChildCanChangeColour"
                  o.childCanChangeColour = (event.propValue == "true")
          //Properties for Container exposed to API    
          else if (isinstance(o, objects.Environment.Container)
              if (event.propName == "Reward"
                  o.reward(event.propValue)
          //Properties for Basket exposed to API    
          else if (isinstance(o, objects.Environment.Basket)
              if (event.propName == "PlayFanfare"
                  o.playFanfare()
          //Properties for Cloud exposed to API    
          else if (isinstance(o, objects.Environment.Cloud)
              if (event.propName == "CanRain"
                  o.canRain = (event.propValue == "true")
      else
          Logger.warning("setObjectProperty was called with object which is not in the objects list")*/
  }
              
  public void OnRemoveObject(Event event)
  {
    if (int(event.objId) in app.canvas.objects)
    {
        o =app.canvas.objects[int(event.objId)]
        o.remove();
    }
  }
  
  public void OnStartAnnotator(Event event)
  {
    if (null == Annotator)
       Annotator = Annotator.Annotator();
  }
      
  public void OnStopAnnotator(Event event)
  {
    if (Annotator != null)
    {
       Annotator.done();
       Annotator = null;
    }
  }
    
  public void OnAnnotatorDrawing(Event event)
  {
    if (Annotator != null)
       Annotator.drawingFeature(true);
  }
      
  public void OnAnnotatorNoDrawing(Event event)
  {
    if (Annotator != null)
       Annotator.drawingFeature(false);
  }
      
  public void OnDraw()
  {
   draw();
  }
  
  public void OnIdle(Event event)
  {
    draw();
    event.RequestMore();
  }

  public void InitGL()
  {
    gl.glMatrixMode(GL2.GL_MODELVIEW);
    gl.glClearDepth(1.0);
    
    gl.glEnable(GL2.GL_DEPTH_TEST);
    gl.glEnable(GL2.GL_NORMALIZE);

    gl.glEnable(GL2.GL_COLOR_MATERIAL);
    gl.glEnable(GL2.GL_BLEND);
    gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA);

    gl.glShadeModel(GL2.GL_SMOOTH);
    gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST);
    gl.glEnable(GL2.GL_LINE_SMOOTH);

    gl.glEnable(GL2.GL_LIGHTING);
    gl.glEnable(GL2.GL_LIGHT0);

    setLight(0.8);
    targetLightLevel = 0.8;
                  
    lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE);
  }
                                             
  public void setLight(float brightness)
  {
     lightLevel = brightness;
       
     // Create light components
     float al = brightness;
     float dl = max(0, brightness-0.2);
     float sl = max(0, brightness-0.8);
     ambientLight = [ al, al, al, 1.0 ];
     diffuseLight = [ dl, dl, dl, 1.0 ];
     specularLight = [ sl, sl, sl, 1.0 ];
       
     // Assign created components to GL2.GL_LIGHT0
     gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight);
     gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight);
     gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight);
  }
             
  public void clearScene(boolean quick)
  {
    if (hasattr("background") andbackground
       background.remove();
    for (id,object in sceneElements.items())
      object.remove(!quick);
    for(id,object in objects.items())
    {
      object.interactive = false;
      object.remove(!quick);
    }
  }
  
  public void draw()
  {
    if (this.printFPS)
    {
       frameCounter += 1
      if (time.time() -last_time >= 1)
      {
         float current_fps = frameCounter / (time.time() -last_time);
          //print current_fps, 'fps'
         frameCounter = 0;
         last_time = time.time();
      }
    }
    if (this.targetLightLevel != lightLevel)
    {
       float newlight = lightLevel + (this.targetLightLevel -lightLevel)/100;
       if (Math.abs(newlight-this.targetLightLevel) < 0.01)
         newlight = targetLightLevel);
       setLight(newlight);
    }

    // clear color and depth buffers
    gl.glClearColor(this.clear_colour[0],clear_colour[1],clear_colour[2],clear_colour[3]);
    gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT);
    
    gl.glMatrixMode(GL2.GL_MODELVIEW);
    gl.glLoadIdentity();
    gl.gluLookAt (this.cameraPos[0],cameraPos[1],cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

    // position of the light needs to be set after the projection
    gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ]);
    
   renderBackground ();
   renderEnvironment();          
   renderObjects();
   renderAgents();

    if (this.renderPiavca)
    {
      Piavca.Core.getCore().timeStep(); 
      Piavca.Core.getCore().prerender();
      Piavca.Core.getCore().render();
    }
    
    if (this.Annotator)
     Annotator.render();

    SwapBuffers();
  }
      
  public void addBackground(Object object)
  {
     background = object;
  }
          
  public void renderBackground()
  {
    if (hasattr("background") andbackground && hasattr(this.background, "render"))
       background.render();
  }
              
  public void removeBackground()
  {
     background = null;
  }

  public void addSceneElement(Object object)
  {
    sceneElementCount =sceneElementCount + 1;
    sceneElements[this.sceneElementCount] = object;
    returnsceneElementCount;
  }
          
  public void removeSceneElement(String id)
  {
    sceneElements.remove(id);
  }

  public void renderEnvironment()
  {
    for (String id : sceneElements.keys())
    {
      Object object = sceneElements[id];
      if (hasattr(object, "render"))
      {
          gl.glPushName (int(id));
          object.render();
          gl.glPopName ();
      }
    }
  }
  
  public void getMenus()
  {/*
      menus = []
      for id, object insceneElements.items()
          if (isinstance(object, environment.Menu.UserMenu)
              menus.append(object)
      return menus;*/
  }
      
  public int addObject(Object object, Map<String, String> props)
  {
     objectCount++;
     objects.put(objectCount.toString(), object);
     rlPublisher.objectAdded(objectCount.toString(), props);
     return objectCount;
  }
      
  public void removeObject(String id)
  {
     objects.remove(id);
     rlPublisher.objectRemoved(id);
  }

  public void renderObjects(boolean hitTest)
  {
    for (String id : objects.keySet())
    {
      Object object = objects.get(id);
      if (hasAttr(object, "render"))
      {
        gl.glPushName (Integer.parseInt(id));
        object.render(hitTest);
        gl.glPopName ();
      }
    }
    
      //objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true,objects.iteritems()))
      //collisions = hitTest(objectsToTest)               
      //for (pair in collisions)                
      //  objectCollision(pair[0], pair[1],app);
  }
  
  public int addAgent(Object agent, Map<String, String> props)
  {
    //renderPiavca = true
    agentCount++;
    agents.put(agentCount.toString(), agent);
    rlPublisher.agentAdded(agentCount.toString(), agent.props);
    return agentCount;
  }
      
  public void removeAgent(String id)
  {
    agents.remove(id);
    // if (len(this.agents) == 0
        //renderPiavca = false
    rlPublisher.agentRemoved(id);
  }
          
  public void renderAgents()
  {/*
      for id inagents.keys()
          agent =agents[id]
          if (hasattr(agent, "render")
              gl.glPushName (int(id))
              agent.render()
              gl.glPopName ()
      
      objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true,objects.iteritems()))
      agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true,agents.iteritems()))
      collisions =agentHitTest(agentsToTest, objectsToTest)       
                      
      for pair in collisions                 
          agentObjectCollision(pair[0], pair[1],app)
  }

  /*
  public void agentActionStarted(Object callback, String unique_actionid, String agentId, action, details)
  {
     actionLock.acquire()
      // pass
      Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
      if (hasattr("agentPublisher")
         agentPublisher.agentActionStarted(agentId, action, details)

     agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
     actionLock.release()
  }
  
  public void agentActionCompleted(String unique_actionid, boolean success)
  {
     actionLock.acquire()
      // pass
      Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
      if (hasattr("agentPublisher") and unique_actionid inagentActions
          // if (this.agentActions[unique_actionid].callback
              // Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
              //agentActions[unique_actionid].callback.ice_response(success)
          try
              if (success
                 agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId,agentActions[unique_actionid].action,agentActions[unique_actionid].details)
              else
                 agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId,agentActions[unique_actionid].action,agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
          except
              Logger.warning("Incomplete information in completed agent action")
          delagentActions[unique_actionid]
      else
          Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
     actionLock.release();
  }
  */
  
  public Set<String> getObjectIds()
  {
    return objects.keySet();
  }
          
  public String getObjectAtPosition(int x, int y)
  {
    //Logger.trace("info",  "Looking for objects at " + x + "," + y)

    // Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
    
    // Get the current viewport
    viewport = glGetIntegerv(GL2.GL_VIEWPORT);
    
    // Prepare a buffer to hold the results
    gl.glSelectBuffer (100);

    // Put OpenGL into selection mode, and reset the name stack
    gl.glRenderMode(GL2.GL_SELECT);
    gl.glInitNames();
    
    // Only draw in the area under the mouse click
    gl.glMatrixMode(GL2.GL_PROJECTION);
    gl.glPushMatrix();
    gl.glLoadIdentity();
    gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport);
    
    // Multiply the perspective matrix by the pick matrix to restrict the drawing area
   projection();
    
    // Switch to normal mode, render the target to the buffer, and do some further mapping
    gl.glMatrixMode(GL2.GL_MODELVIEW);
   renderObjects(true);
    gl.glMatrixMode(GL2.GL_PROJECTION);
    gl.glPopMatrix();;
    gl.glMatrixMode(GL2.GL_MODELVIEW);

    // Switch back to normal mode and see whether we hit anything
    records = glRenderMode(GL2.GL_RENDER);
    String hitObject = null;
    // Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
//            if (len(records) > 0
//                hitObject = records[len(records)-1].names[0]
//                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
//                    hitObject = records[len(records)-2].names[0]
    distance = 1000;
    for ( record : records)
    {
        if (record.near < distance)
        {
            distance = record.near;
            hitObject = record.names[0];
        }
    }
            
    return hitObject;
  }
      
  public String getAgentAtPosition(int x, int y)
  {/*
      Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
      rx, ry, rz =getWorldCoord((x,y))
      for id inagents.keys()
          agent =agents[id]
          if (hasattr(agent, "avatar")
              c = agent.getXYContour()
              if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                  return id */
      return "";
  }
      
  public float [] getScreenCoord(float[] pos)
  {
    GL2 gl = getGL().getGL2();
    int[] viewport = new int[4];
    double[] modelview = new double[16];
    double[] projection = new double[16];
    
    gl.glGetDoublev(GL2.GL_MODELVIEW_MATRIX, modelview, 0);
    gl.glGetDoublev(GL2.GL_PROJECTION_MATRIX, projection, 0);
    gl.glGetIntegerv(GL2.GL_VIEWPORT, viewport, 0);

    //return getGLU().gluProject(pos[0], pos[1], pos[2], model, projection, viewport);
    return null;
  }
                  
  public void getWorldCoord(float[] pos)
  {
    GL2 gl = getGL().getGL2();
    int[] viewport = new int[4];
    double[] modelview = new double[16];
    double[] projection = new double[16];
    
    gl.glGetDoublev(GL2.GL_MODELVIEW_MATRIX, modelview, 0);
    gl.glGetDoublev(GL2.GL_PROJECTION_MATRIX, projection, 0);
    gl.glGetIntegerv(GL2.GL_VIEWPORT, viewport, 0);
    
    //wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
    //unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport);;
    //return unprojected;
  }

  public void drawBezier(float[][]ctrlPoints, boolean drawPoints, int numStrips)
  {
    GL2 gl = getGL().getGL2();
    gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0, 1, 0, 0, ctrlPoints, 0);
    gl.glEnable(GL2.GL_MAP1_VERTEX_3);
    gl.glBegin(GL2.GL_LINE_STRIP);
    for (int i = 0; i < numStrips; i++)
        gl.glEvalCoord1f((float)i/numStrips);
    gl.glEnd();
    if (drawPoints)
    {
      gl.glPointSize(5);
      gl.glColor3f(1, 1, 0);
      gl.glBegin(GL2.GL_POINTS);
      for (float [] point : ctrlPoints)
        gl.glVertex3f(point[0], point[1], point[2]);
      gl.glEnd();
    }
  }     
              
  public Map<Object, Object> hitTest(Map<String, Object> things, Map<String, Object> otherThings)
  {
    Map<Object, Object> collisions= new HashMap<Object, Object>();
    if (null == otherThings)
    {
      for (String id1 : things.keySet())
      {
        for (String id2 : things.keySet())
        {
          if (id2.compareToIgnoreCase(id1) < 0)
              continue;
          if (id1 != id2)
          {
            Object o1 = things.get(id1);
            Object o2 = things.get(id2);
            float deltaX = o2.pos[0] - o1.pos[0];
            float deltaY = o2.pos[1] - o1.pos[1];
            float deltaZ = o2.pos[2] - o1.pos[2];
            if (isinstance(o1, objects.Plants.EchoesFlower) || isinstance(o2, objects.Plants.EchoesFlower))
            {
              if (isinstance(o1, objects.Plants.EchoesFlower))
              {
                flower = o1;
                other = o2;
              }
              else
              {
                flower = o2;
                other = o1;
              }
              deltaY = flower.pos[1] - other.pos[1];
              if (abs(deltaX) <= other.size && deltaY < (other.size + flower.stemLength) && deltaY > 0)
                collisions.add(o1, o2);
            }
            else
            {
              distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ;
              minDistance = o1.size + o2.size;
              if (distanceSquared < minDistance * minDistance)
                collisions.add(o1,o2);
            }
          }
        }
      }
    }
    else
    {
      for (Object o1 : things)
      {
        for (Object o2 : otherThings)
        {
          deltaX = o2.pos[0] - o1.pos[0];
          deltaY = o2.pos[1] - o1.pos[1];
          deltaZ = o2.pos[2] - o1.pos[2];
          distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ;
          minDistance = o1.size + o2.size;
          if (distanceSquared < minDistance * minDistance)
              collisions.add(o1,o2);
        }
      }
    }
    return collisions;
  }
      
  public void agentHitTest(Map<String, Object> agentsToTest, Map<String, Object> objectsToTest)
  {/*
      noAvatars = dict()
      collisions = []
      for aid, agent in agentsToTest.items()
          if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
              bb = agent.getXYContour()
              for oid, object in objectsToTest.items()
                  if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                      if (object.beingDragged object.draggedOverAgent = agent.id
                      else object.draggedOverAgent = None
                      object.overAgent = agent.id
                      collisions.append([agent, object])
                  else
                      object.draggedOverAgent = None
                      object.overAgent = None                            
          else
              noAvatars[aid] = agent
      if (len(noAvatars) > 0
          collisions +=hitTest(noAvatars, objectsToTest)
      return collisions      */                        
  }
      
  public void saveScreenshot(String name, String path)
  {/*
     // Read in the screen information in the area specified """
      gl.glFinish();
      gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4);
      gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0);
      gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0);
      gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0);
  
      data = glReadPixels(0, 0,size[0],size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE);
      
      if (null == name)
        name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M");
      if (null ==  path)
        path = os.getcwd();
  
      im = PIL.Image.fromstring("RGBA",size, data);
      im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG");*/
  }
}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:572)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-07 10:35:00.514
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:572)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-07 10:35:00.529
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:572)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 10001 2012-05-07 11:05:17.196
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for HashMap [in HashMap.class [in java.util [in C:\Program Files\Java\jre7\lib\rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryMethod.getAttachedJavadoc(BinaryMethod.java:643)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:462)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:621)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:567)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:559)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:142)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2012-05-07 11:05:17.196
!MESSAGE Timed out while retrieving the attached javadoc for HashMap [in HashMap.class [in java.util [in C:\Program Files\Java\jre7\lib\rt.jar]]] 
