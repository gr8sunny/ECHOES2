!SESSION 2012-05-06 13:30:01.515 -----------------------------------------------
eclipse.buildId=M20110909-1335
java.version=1.7.0
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86_64

This is a continuation of log file C:\Keith\echoes\EchoesJava\.metadata\.bak_6.log
Created Time: 2012-05-06 15:25:25.888

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:25.890
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:25.892
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:26.561
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


    public class EchoesGLCanvas(glcanvas.GLCanvas)
        
        public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:26.564
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:26.566
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:27.233
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


    public class EchoesGLCanvas(glcanvas.GLCanvas)
        
        public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:27.236
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:27.238
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:27.908
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


    public class EchoesGLCanvas(glcanvas.GLCanvas)
        
        public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:27.912
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:27.913
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:28.574
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


    public class EchoesGLCanvas(glcanvas.GLCanvas)
        
        public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:28.574
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:28.574
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:370)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:330)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:34.433
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


    public class EchoesGLCanvas(glcanvas.GLCanvas)
        
        public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:34.436
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:34.438
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:36.844
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
        
        public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:36.847
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:36.849
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:37.683
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
        
        public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:142)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:37.686
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:142)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:37.688
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:142)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:39.037
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
        public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:39.041
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:39.043
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:39.140
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
        public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:39.143
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:39.145
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:42.751
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:42.755
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:42.757
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:43.703
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:119)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:220)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:198)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:284)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:43.707
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:119)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:220)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:198)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:284)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:43.709
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:119)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:220)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:198)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:284)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:44.383
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.text.correction.ASTResolving.createQuickFixAST(ASTResolving.java:1132)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:122)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:220)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:198)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:284)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:44.387
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.ui 4 0 2012-05-06 15:25:44.389
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (java.lang.IllegalArgumentException)
	at org.eclipse.swt.SWT.error(SWT.java:4282)
	at org.eclipse.swt.SWT.error(SWT.java:4197)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:138)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4140)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
Caused by: java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.text.correction.ASTResolving.createQuickFixAST(ASTResolving.java:1132)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:122)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:220)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:198)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:284)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)
	... 23 more

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:44.392
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:44.394
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:45.743
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void __init__(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:45.747
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:45.749
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:47.446
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void EchoesGLCanvas(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:47.449
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:47.451
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:48.121
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void EchoesGLCanvas(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:48.124
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:48.126
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:49.647
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void EchoesGLCanvas(parent)
            
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:49.651
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:49.653
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:50.638
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void EchoesGLCanvas(parent)
  {
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2012-05-06 15:25:50.641
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2012-05-06 15:25:50.643
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2012-05-06 15:25:50.690
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package renderingEngine.visual;


public class EchoesGLCanvas(glcanvas.GLCanvas)
{      
  public void EchoesGLCanvas(parent)
  {
            Logger.trace("info",  "init canvas")
            attribList = (glcanvas.WX_GL2.GL_RGBA, # RGBA
                      gl.glcanvas.WX_GL2.GL_DOUBLEBUFFER, # Double Buffered
                      gl.glcanvas.WX_GL2.GL_DEPTH_SIZE, 24) # 24 bit
            
            gl.glcanvas.GLCanvas.__init__(parent, -1, attribList=attribList)
            this.init = false
            # initial mouse position
            this.size = None
            this.Bind(wx.EVT_ERASE_BACKGROUND, this.OnEraseBackground)
            this.Bind(wx.EVT_SIZE, this.OnSize)
            this.Bind(wx.EVT_PAINT, this.OnPaint)
            this.Bind(wx.EVT_LEFT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_LEFT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_LEFT_DCLICK, this.OnMouseDoubleClick)
            this.Bind(wx.EVT_RIGHT_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_RIGHT_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MIDDLE_DOWN, this.OnMouseDown)
            this.Bind(wx.EVT_MIDDLE_UP, this.OnMouseUp)
            this.Bind(wx.EVT_MOTION, this.OnMouseMotion)
            this.Bind(wx.EVT_CHAR, this.OnKeyboard)
            this.Bind(wx.EVT_IDLE, this.OnIdle)
            
            # Listen for the events from the touch-server too
            this.Bind(EVT_ECHOES_CLICK_EVENT, this.OnEchoesClick)
            this.Bind(EVT_ECHOES_POINT_DOWN_EVENT, this.OnEchoesPointDown)
            this.Bind(EVT_ECHOES_POINT_MOVED_EVENT, this.OnEchoesPointMoved)
            this.Bind(EVT_ECHOES_POINT_UP_EVENT, this.OnEchoesPointUp)
            
            this.Bind(EVT_CREATE_PIAVCA_AVATAR, this.OnCreatePiavcaAvatar)
            this.Bind(EVT_LOAD_SCENARIO, this.OnLoadScenario)
            this.Bind(EVT_END_SCENARIO, this.OnEndScenario)
            this.Bind(EVT_ADD_OBJECT, this.OnAddObject)
            this.Bind(EVT_SET_OBJECT_PROPERTY, this.OnSetObjectProperty)
            this.Bind(EVT_REMOVE_OBJECT, this.OnRemoveObject)
            this.Bind(EVT_START_ANNOTATOR, this.OnStartAnnotator)
            this.Bind(EVT_STOP_ANNOTATOR, this.OnStopAnnotator)
            this.Bind(EVT_ANNOTATOR_DRAWING, this.OnAnnotatorDrawing)
            this.Bind(EVT_ANNOTATOR_NO_DRAWING, this.OnAnnotatorNoDrawing)
            
            this.scaleBias = 1.0
            this.tracking = 1
            
            this.cameraPos = (100.0, 100.0, 100.0)
            this.orthoCoordWidth = 10
            this.orthoCoordDepth = 100
            this.aspectRatio = 1.0
            this.aspectFourByThree = true
            
            this.dragging = false
                                    
            this.clear_colour = (0,0,0,0)
            
            this.currentScene = None
            this.sceneElementCount = 0
            this.sceneElements = dict()
            this.objectCount = 0
            this.objects = dict()
            this.agentCount = 0
            this.agents = dict()
            this.drag = dict()      #id's of drag events on objects 
            this.bgtouch = dict()   #id's of drag events on background
            
            this.userList = []
            
            this.agentActions = dict()
            this.actionLock = thread.allocate_lock()
            this.piavcaAvatars = dict()
            
            this.touchEnabled = false
            this.Annotator = None
            
            this.scenario = ""
            this.publishScore = true
            this.targetLightLevel = this.lightLevel = 0.8

            this.frame = parent
            this.app = parent.app
            
            this.last_time = time.time()
            this.frameCounter = 0
            this.printFPS = false
            
            this.renderPiavca = false
            this.InitGL()
            
        public void setCurrent()
            if (this.GetContext()
                this.SetCurrent()                
            
        public void setClearColour(r, g, b, a)
            this.clear_colour = (r,g,b,a)

        public void OnEraseBackground(event)
            pass # Do nothing, to avoid flashing.

        public void projection()
#            gl.gluPerspective( 45.0, this.aspectRatio, 0.5, 50.0 ); 
            gl.glOrtho(-1*this.orthoCoordWidth/2, this.orthoCoordWidth/2, -1*this.orthoCoordWidth/2/this.aspectRatio, this.orthoCoordWidth/2/this.aspectRatio, -1*this.orthoCoordDepth/2, this.orthoCoordDepth/2)

        public void OnSize(event)
            size = this.size = this.GetClientSize()
            if (size.width >=0 
                width = size.width
            else
                width = 0
            if (size.height >=0 
                height = size.height
            else
                height = 0
            if (this.GetContext()
                this.SetCurrent()
                gl.glViewport(0, 0, width, height)
                if (width > 0 and height > 0
                    this.aspectRatio = float(width)/float(height)
                    if (this.aspectFourByThree
                        this.aspectRatio = this.aspectRatio * 4/3
                    Logger.trace("info",  "setting perspective and viewport with size " + str(width) + " x " + str(height) + "aspect ratio " + str(this.aspectRatio))
                    gl.glMatrixMode(GL2.GL_PROJECTION)
                    gl.glLoadIdentity()
                    this.projection()
            event.Skip()

        public void getRegionCoords(key)
            w = float(this.orthoCoordWidth)
            h = float(this.orthoCoordWidth / this.aspectRatio)
            d = float(this.orthoCoordDepth)
            return {
                    "all" [(-1*w/2,-1*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "all80" [(-0.8*w/2,-0.8*h/2,-0.8*d/2), (0.8*w/2,0.8*h/2, 0.8*d/2)], 
                    "all70" [(-0.7*w/2,-0.7*h/2,-0.7*d/2), (0.7*w/2,0.7*h/2, 0.7*d/2)], 
                    "all60" [(-0.6*w/2,-0.6*h/2,-0.6*d/2), (0.6*w/2,0.6*h/2, 0.6*d/2)], 
                    "all50" [(-0.5*w/2,-0.5*h/2,-0.5*d/2), (0.5*w/2,0.5*h/2, 0.5*d/2)], 
                    "left" [(-1*w/2,-1*h/2,-1*d/2), (-1*w/6, h/2, d/2)],
                    "middle" [(-1*w/6, -1*h/2, -1*d/2), (w/6, h/2, d/2)],
                    "right" [(w/6, -1*h/2, -1*d/2), (w/2, h/2, d/2)],
                    "v-top" [(-1*w/2,0.3*h/2,-1*d/2), (w/2,h/2, d/2)], 
                    "v-middle" [(-1*w/2,-0.3*h/2,-1*d/2), (w/2,0.3*h/2, d/2)], 
                    "v-bottom" [(-1*w/2,-1*h/2,-1*d/2), (w/2,-0.3*h/2, d/2)], 
                    "3x3" [[(-1*w/2, h/6, -1*d/2), (-1*w/6, h/2, d/2)],        # top-left
                            [(-1*w/6, h/6, -1*d/2), (w/6, h/2, d/2)],           # top-middle
                            [(w/6, h/6, -1*d/2), (w/2, h/2, d/2)],              # top-right
                            [(-1*w/2, -1*h/6, -1*d/2), (-1*w/6, h/6, d/2)],     # middle-left
                            [(-1*w/6, -1*h/6, -1*d/2), (w/6, h/6, d/2)],        # middle-middle
                            [(w/6, -1*h/6, -1*d/2), (w/2, h/6, d/2)],           # middle-right
                            [(-1*w/2, -1*h/2, -1*d/2), (-1*w/6, -1*h/6, d/2)],  # bottom-left
                            [(-1*w/6, -1*h/2, -1*d/2), (w/6, -1*h/6, d/2)],     # bottom-middle
                            [(w/6, -1*h/2, -1*d/2), (w/2, -1*h/6, d/2)]         # bottom-right
                            ],
                    "ground" [(-1*w/2,-0.7*h/2,-1*d/2), (w/2,-0.8*h/2, d/2)],
                    "middle-ground" [(-1*w/2,-0.2*h/2,-1*d/2), (w/2,-0.7*h/2, d/2)],
                    "sky" [(-1*w/2,0.95*h/2,-1*d/2), (w/2,0.8*h/2, d/2)]
                    
            }[key]
            
        public void get3x3Neighbours(region, distance)
            if (distance == 0
                return [region]
            else
                return [
                        [[1,4,3], [2,5,8,7,6]],
                        [[0,2,3,4,5], [6,7,8]],
                        [[1,4,5], [0,3,6,7,8]],
                        [[0,1,4,7,6], [2,5,8]],
                        [[0,1,2,3,5,6,7,8], []],
                        [[1,2,4,7,8], [0,3,6]],
                        [[3,4,7], [0,1,2,5,8]],
                        [[6,3,4,5,8], [0,1,2]],
                        [[7,4,5], [0,1,2,3,6]]
                        ][region][distance-1]

        public void resize(size)
            pass

        public void OnPaint(event)
            dc = wx.PaintDC()
            this.SetCurrent()
            if (not this.init
                this.InitGL()
                this.init = true
            this.OnDraw()

        public void OnMouseDown(evt)
            # this.CaptureMouse()
            x, y = evt.GetPosition()

            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.startDrag((x,y))
                else
                    id = this.getObjectAtPosition(x, y)
                    evt.id = 0
                    if ((id > -1)
                        # print "Touching object " + str(id), " in region ", this.objects[id].currentRegion
                        this.rlPublisher.userTouchedObject(str(id))
                        this.drag[evt.id] = id
                        this.objects[id].startDrag((x, y))

        public void OnMouseUp(evt)
            this.dragging = false
            
            if ((not(this.touchEnabled))
                if (this.Annotator
                    this.Annotator.stopDrag()
                else
                    evt.id = 0
                    if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                        if (this.objects[this.drag[evt.id]].locationChanged)
                            this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                        this.objects[this.drag[evt.id]].stopDrag()
                    if (evt.id in this.drag)
                        del this.drag[evt.id]

        public void OnMouseMotion(evt)
            if (evt.Dragging()
                x, y = evt.GetPosition()
                this.Refresh(false)
                
                if ((not(this.touchEnabled))
                    if (this.Annotator
                        this.Annotator.drag((x,y))
                    else
                        evt.id = 0
                        if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                            this.objects[this.drag[evt.id]].drag([x, y])                        

        public void OnMouseDoubleClick(evt)
            x, y = evt.GetPosition()
            this.processClick(x, y)            
                    
        public void processClick(x, y)
            if (this.Annotator
                this.Annotator.click((x,y))
            else
                id = this.getObjectAtPosition(x, y)
                if ((id > -1)
                    Logger.trace("info",  "clicked object is " + str(id))
                    this.objects[id].click("User")
                    this.rlPublisher.userTouchedObject(str(id))
                else
                    id = this.getAgentAtPosition(x,y)
                    if ((id > -1)
                        Logger.trace("info",  "clicked agent is " + str(id))
                        this.agents[id].click(this.getWorldCoord((x,y,0)))
                        this.rlPublisher.userTouchedAgent(str(id))
                menus = this.getMenus()
                for menu in menus
                    menu.click(this.getWorldCoord((x,y,0)))
                        
        public void OnEchoesClick(evt)
            Logger.trace("info",  "Click from ECHOES x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            this.processClick(framePos[0], framePos[1])

        public void OnEchoesPointDown(evt)
            Logger.trace("info",  "Point down from ECHOES id = " + str(evt.id) + "; x = " + str(evt.x) + "; y = " + str(evt.y))
            framePos = this.ScreenToClient([evt.x, evt.y])
            Logger.trace("info",  "Location on screen " + str(framePos))
            if (this.Annotator
                this.Annotator.startDrag(framePos)
            else
                id = this.getObjectAtPosition(framePos[0], framePos[1])
                if ((id > -1)
                    Logger.trace("info",  "Touching object " + str(id) + " with gesture #" + str(evt.id))
                    this.rlPublisher.userTouchedObject(str(id))
                    this.drag[evt.id] = id
                    this.objects[id].startDrag(framePos)
                else
                    this.bgtouch[evt.id] = framePos
                    this.agentPublisher.agentActionStarted("User", "touch_background", [str(framePos[0]), str(framePos[1])])

        public void OnEchoesPointMoved(evt)
            framePos = this.ScreenToClient([evt.x, evt.y])
            if (this.Annotator
                this.Annotator.drag(framePos)
            else
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    this.objects[this.drag[evt.id]].drag(framePos)

        public void OnEchoesPointUp(evt)
            Logger.trace("info",  "Point up from ECHOES id = " + str(evt.id))
            if (this.Annotator
                this.Annotator.stopDrag()
            else            
                if (evt.id in this.drag and this.drag[evt.id] in this.objects)
                    if (this.objects[this.drag[evt.id]].locationChanged)
                        this.agentPublisher.agentActionCompleted("User", "drag", [str(this.drag[evt.id])])
                    this.objects[this.drag[evt.id]].stopDrag()
                if (evt.id in this.drag)
                    del this.drag[evt.id]
                if (evt.id in this.bgtouch)
                    this.agentPublisher.agentActionCompleted("User", "touch_background", [str(this.bgtouch[evt.id][0]), str(this.bgtouch[evt.id][1])])
                    del this.bgtouch[evt.id]
                
        public void OnKeyboard(evt)
            #print evt.KeyCode
            try
                if (type(evt.KeyCode) == int
                    char = chr(evt.KeyCode)
                else
                    char = chr(evt.KeyCode())
            except ValueError
                # print "KeyInput.KeyPressedCB not ASCII"
                return

            # print "KeyInput.KeyPressedCB", char
            
            if (char == 'f'
                this.app.fullscreen(not this.app.fullscreenFlag)
            
            if (char == 'a'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Axis)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Axis(this.app)
                                    
            if (char == 'g'
                removed = false
                for id, object in this.sceneElements.items()
                    if (isinstance(object, environment.HelperElements.Grid3x3)
                        object.remove()
                        removed = true
                if (not removed
                    environment.HelperElements.Grid3x3(this.app)              

        public void OnCreatePiavcaAvatar(evt)
            if ((evt.type in this.piavcaAvatars)
                # Re-add it
                this.piavcaAvatars[evt.type].id = this.addAgent(this.piavcaAvatars[evt.type], dict())
                this.piavcaAvatars[evt.type].startPostion()
                if (hasattr(evt, "pose")
                    print "Looking at point ..."
                    this.piavcaAvatars[evt.type].lookAtPoint(0, 3, 0)
                this.rlPublisher.agentAdded(str(this.agentCount), dict())
                evt.callback.ice_response(str(this.piavcaAvatars[evt.type].id))
            else
                # Create and auto-add the avatar
                if (evt.type == "Paul"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Paul(this.app, evt.autoadd, callback=evt.callback)
                else if (evt.type == "Andy"
                    this.piavcaAvatars[evt.type] = agents.PiavcaAvatars.Andy(this.app, evt.autoadd, callback=evt.callback)
                else
                    Logger.warning("Unknown avatar type " + evt.name)
                    evt.callback.ice_response("")
                
        public void OnLoadScenario(evt)
            this.scenario = evt.name
            if (evt.name == "Intro"
                this.renderPiavca = false
                environment.Backgrounds.Sky(this.app)
                bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true)
                bubble.colour = "green"
                m = this.getRegionCoords("middle")
                bubble.setStartPos((m[0][0], 0,0))
                bubble.interactive = false
                bubble.moving = false
                bubble.size = 0.6                
                userList = this.userList
                if (Ice.Application.communicator() and (not(userList) or (len(userList) == 0))
                    userList = Ice.Application.communicator().getProperties().getPropertyAsListWithpublic voidault('RenderingEngine.UserList', ['Tim', 'Tom', 'Jake', 'Sam'])
                environment.Menu.UserMenu(this.app, true, true,
                                          userlist=userList, 
                                          pos=(0,0,0))   
            
            else if (evt.name == "BubbleWorld"
                this.renderPiavca = false
                this.score = 0
                environment.Backgrounds.Sky(this.app, true, true)
    
            else if ("Garden" in evt.name
                bg = environment.Backgrounds.Garden(this.app, fadeIn=true)
                this.renderPiavca = true
                this.score = 0
                # public voidault is visual/images/GardenBackExplore.png
                if (evt.name == "GardenTask"
                    bg.setImage("visual/images/GardenBackTask.png")
                else if (evt.name == "GardenSocialGame"
                    bg.setImage("visual/images/GardenBackSocialGame.png")
                else if (evt.name == "GardenVeg"
                    bg.setImage("visual/images/VegBackground.png")
                    
            this.currentScene = evt.name
            this.rlPublisher.scenarioStarted (evt.name)
            evt.callback.ice_response()
            
        public void OnEndScenario(evt)
            this.scenario = None
            if (evt.name == "Intro" or evt.name == "BubbleWorld" or "Garden" in evt.name

                # Introduce a new transition bubble except in the Intro scene
                trans_bubble = None
                if (evt.name == "Intro"
                    for id,object in this.objects.items()
                        if (isinstance(object, objects.Bubbles.EchoesBubble)
                            trans_bubble=object
                            break
                    for id, object in this.sceneElements.items()
                        if (isinstance(object, environment.Menu.UserMenu)
                            object.remove(false)                    
                                            
                if (not trans_bubble
                    trans_bubble = objects.Bubbles.EchoesBubble(this.app, true, fadeIn=true, fadingFrames=100)
                    trans_bubble.setStartPos((0,0,0))
                
                trans_bubble.interactive = false
                trans_bubble.colour = "red"
                trans_bubble.moving = true
                trans_bubble.setTargetPos((this.orthoCoordWidth, this.orthoCoordWidth / this.aspectRatio, this.orthoCoordDepth))
                trans_bubble.removeAtTargetPos = true
                trans_bubble.removeAction = "PublishScenarioEnded"
                trans_bubble.callback = evt.callback
                trans_bubble.removeActionArgs = evt.name                                

            else
                Logger.warning("Unknown scenario in endScenario " + evt.name)
                evt.callback.ice_response()
                
            this.renderPiavca = false
            this.currentScene = None
            
        public void OnAddObject(evt)
            if (evt.type == "Flower"
                objects.Plants.EchoesFlower(this.app, true, fadeIn = false, callback=evt.callback)
            else if (evt.type == "Bubble"
                objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "IntroBubble"
                b = objects.Bubbles.EchoesBubble(this.app, true, fadeIn = true, callback=evt.callback)
                b.colour = "green"
                if (this.currentScene == "BubbleWorld"
                    b.willBeReplaced = true
                else
                    b.willBeReplaced = false
                b.setStartPos((0,5,0.5))
            else if (evt.type == "Pot"
                objects.Plants.Pot(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Ball"
                objects.PlayObjects.Ball(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Pond"
                objects.Environment.Pond(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Cloud"
                objects.Environment.Cloud(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Container"
                objects.Environment.Container(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Sun"
                objects.Environment.Sun(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "LifeTree"
                objects.Plants.LifeTree(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "MagicLeaves"
                objects.Plants.MagicLeaves(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Basket"
                objects.Environment.Basket(this.app, true, fadeIn = true, callback=evt.callback)
            else if (evt.type == "Shed"
                objects.Environment.Shed(this.app, true, fadeIn = true, callback=evt.callback)
            else
                Logger.warning("Cannot create object of type " + evt.type)
                evt.callback.ice_response("")
        
        public void OnSetObjectProperty(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                # Generic properties
                if (evt.propName == "Pos"
                    pos = str(evt.propValue)
                    if (pos.startswith("(") pos = pos[1]
                    if (pos.endswith(")") pos = pos[-1]
                    pos = pos.split(",")
                    try
                        x = float(pos[0])
                    except ValueError
                        Logger.warning("setObjectProperty Invalid coordinate for x")
                        return
                    try
                        y = float(pos[1])
                    except ValueError
                        try
                            f = this.getRegionCoords(pos[1].strip())
                            y = f[1][1]
                        except ValueError
                            Logger.warning("setObjectProperty Invalid coordinate for y")
                            return
                    try
                        z = float(pos[2])
                    except ValueError
                        if (pos[2] == "front" z = 1
                        else if (pos[2] == "back" z = -1
                        else z = 0

                    o.pos = [x,y,z]
                
                if (evt.propName == "Size" and hasattr(o, "size")
                    o.size = float(evt.propValue)                
                
                if (evt.propName == "Colour" and hasattr(o, "colour")
                    o.colour = str(evt.propValue)
                    
                if (evt.propName == "Interactive"
                    o.interactive = (evt.propValue == "true")
                            
                #Properties for Bubbles exposed to API
                if (isinstance(o, objects.Bubbles.EchoesBubble)
                    if (evt.propName == "Size" 
                        if (evt.propValue == "Bigger"
                            o.grow()
                    else if (evt.propName == "Replace" 
                        o.willBeReplaced = (evt.propValue == "true")
                #Properties for Flowers exposed to API    
                else if (isinstance(o, objects.Plants.EchoesFlower)
                    if (evt.propName == "MoveToBasket"
                        try 
                            id = int(evt.propValue)
                        except 
                            id = None 
                        o.moveToBasket(id)
                    else if (evt.propName == "IntoBubble"
                        o.intoBubble()
                    else if (evt.propName == "IntoBall"
                        o.intoBall()
                    else if (evt.propName == "CanTurnIntoBall" 
                        o.canTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "CanTurnIntoBubble" 
                        o.canTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBall" 
                        o.childCanTurnIntoBall = (evt.propValue == "true")
                    else if (evt.propName == "ChildCanTurnIntoBubble" 
                        o.childCanTurnIntoBubble = (evt.propValue == "true")
                    else if (evt.propName == "GrowToSize" 
                        if (evt.propValue == "Max"
                            o.growToSize = o.maxSize
                        else
                             o.growToSize = float(evt.propValue)
                #Properties for Pots exposed to API
                else if (isinstance(o, objects.Plants.Pot)
                    if (evt.propName == "GrowFlower"
                        o.growFlower()
                    if (evt.propName == "StackIntoTree" and o.stack
                        o.stack.intoTree()
                #Properties for Stacks exposed to API
                else if (isinstance(o, objects.Plants.Stack)
                    if (evt.propName == "StackIntoTree"
                        o.intoTree()
                #Properties for Ball exposed to API    
                else if (isinstance(o, objects.PlayObjects.Ball)
                    if (evt.propName == "BounceWithinScene"
                        o.bounceWithinScene = (evt.propValue == "true")
                    if (evt.propName == "ChildCanChangeColour"
                        o.childCanChangeColour = (evt.propValue == "true")
                #Properties for Container exposed to API    
                else if (isinstance(o, objects.Environment.Container)
                    if (evt.propName == "Reward"
                        o.reward(evt.propValue)
                #Properties for Basket exposed to API    
                else if (isinstance(o, objects.Environment.Basket)
                    if (evt.propName == "PlayFanfare"
                        o.playFanfare()
                #Properties for Cloud exposed to API    
                else if (isinstance(o, objects.Environment.Cloud)
                    if (evt.propName == "CanRain"
                        o.canRain = (evt.propValue == "true")
            else
                Logger.warning("setObjectProperty was called with object which is not in the objects list")

                
        public void OnRemoveObject(evt)
            if (int(evt.objId) in this.app.canvas.objects
                o = this.app.canvas.objects[int(evt.objId)]
                o.remove()
            else
                Logger.warning("No object " + evt.objId + " in world, not removing")
            evt.callback.ice_response()
        
        public void OnStartAnnotator(evt)
            if (not this.Annotator
                this.Annotator = Annotator.Annotator(this.app)

        public void OnStopAnnotator(evt)
            if (this.Annotator
                this.Annotator.done()
                del this.Annotator
                this.Annotator = None

        public void OnAnnotatorDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(true)
                
        public void OnAnnotatorNoDrawing(evt)
            if (this.Annotator
                this.Annotator.drawingFeature(false)
                
        public void OnDraw()
            this.draw()

        public void OnIdle(evt)
            this.draw()
            evt.RequestMore()

        public void InitGL()
            this.custom_init()
            Logger.trace("info",  "EchoesGLCanvas.InitGL()")

            # set viewing projection 
            # done in OnSize

            # model projection mode
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glClearDepth(1.0)
            
            gl.glEnable(GL2.GL_DEPTH_TEST)
            gl.glEnable(GL2.GL_NORMALIZE)

            gl.glEnable(GL2.GL_COLOR_MATERIAL)
            gl.glEnable(GL2.GL_BLEND)
            gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA)

            gl.glShadeModel(GL2.GL_SMOOTH)
            gl.glHint(GL2.GL_LINE_SMOOTH_HINT, GL2.GL_NICEST)
            gl.glEnable(GL2.GL_LINE_SMOOTH)

            gl.glEnable(GL2.GL_LIGHTING)
            gl.glEnable(GL2.GL_LIGHT0)

            this.setLight(0.8)
            this.targetLightLevel = 0.8
                        
            this.lineWidthRange = glGetIntegerv(GL2.GL_LINE_WIDTH_RANGE)
            try
                this.lineWidthRange[1]
            except IndexError
                Logger.warning( "*** HACK *** setting lineWidthRange manually")
                this.lineWidthRange = [1, 10]
                                               
        public void setLight(brightness=1.0)
            
            this.lightLevel = brightness
             
            # Create light components
            al = brightness
            dl = max(0, brightness-0.2)
            sl = max(0, brightness-0.8)
            ambientLight = [ al, al, al, 1.0 ]
            diffuseLight = [ dl, dl, dl, 1.0 ]
            specularLight = [ sl, sl, sl, 1.0 ]
             
            # Assign created components to GL2.GL_LIGHT0
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, ambientLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, diffuseLight)
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_SPECULAR, specularLight)

                                                               
        public void custom_init()
            pass
                                    
        public void clearScene(quick=false)
            if (hasattr("background") and this.background
                this.background.remove()
            for id,object in this.sceneElements.items()
                object.remove(not quick)
            for id,object in this.objects.items()
                object.interactive = false
                object.remove(not quick)
            # for id,agent in this.agents.items()
                # agent.remove()                            
                                                
        public void draw()
            if (this.printFPS
                this.frameCounter += 1
                if (time.time() - this.last_time >= 1
                    current_fps = this.frameCounter / (time.time() - this.last_time)
                    print current_fps, 'fps'
                    this.frameCounter = 0
                    this.last_time = time.time()
            if (this.targetLightLevel != this.lightLevel
                newlight = this.lightLevel + (this.targetLightLevel - this.lightLevel)/100
                if (abs(newlight-this.targetLightLevel) < 0.01 newlight = this.targetLightLevel
                this.setLight(newlight)

            # clear color and depth buffers
            gl.glClearColor(this.clear_colour[0], this.clear_colour[1], this.clear_colour[2], this.clear_colour[3])
            gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
            
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            gl.glLoadIdentity()
            gl.gluLookAt (this.cameraPos[0], this.cameraPos[1], this.cameraPos[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

            # position of the light needs to be set after the projection
            gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_POSITION, [-4, 2.0, 10.0, 1.0 ])
            
            this.renderBackground ()
            this.renderEnvironment()            
            this.renderObjects()
            this.renderAgents()

            if (this.renderPiavca
                Piavca.Core.getCore().timeStep(); 
                Piavca.Core.getCore().prerender();
                Piavca.Core.getCore().render();

            if (this.Annotator
                this.Annotator.render()

            this.SwapBuffers()
            
        public void addBackground(object)
            this.background = object
            
        public void renderBackground()
            if (hasattr("background") and this.background and hasattr(this.background, "render")
                this.background.render()
                
        public void removeBackground()
            this.background = None

        public void addSceneElement(object)
            this.sceneElementCount = this.sceneElementCount + 1
            this.sceneElements[this.sceneElementCount] = object
            return this.sceneElementCount
            
        public void removeSceneElement(id)
            del this.sceneElements[id]

        public void renderEnvironment()
            for id in this.sceneElements.keys()
                object = this.sceneElements[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render()
                    gl.glPopName ()
            
        public void getMenus()
            menus = []
            for id, object in this.sceneElements.items()
                if (isinstance(object, environment.Menu.UserMenu)
                    menus.append(object)
            return menus
            
        public void addObject(object, props)
            this.objectCount = this.objectCount + 1
            this.objects[this.objectCount] = object
            this.rlPublisher.objectAdded(str(this.objectCount), props)
            return this.objectCount
            
        public void removeObject(id)
            del this.objects[id]
            this.rlPublisher.objectRemoved(str(id))

        public void renderObjects(hitTest=false)
            for id in this.objects.keys()
                object = this.objects[id]
                if (hasattr(object, "render")
                    gl.glPushName (int(id))
                    object.render(hitTest)
                    gl.glPopName ()
            objectsToTest = dict(filter(lambda item hasattr(item[1], "objectCollisionTest") and item[1].objectCollisionTest==true, this.objects.iteritems()))
            collisions = this.hitTest(objectsToTest)  
                            
            for pair in collisions                 
                objectCollision(pair[0], pair[1], this.app)
            
        public void addAgent(agent, props)
            # this.renderPiavca = true
            this.agentCount = this.agentCount + 1
            this.agents[this.agentCount] = agent
            # this.rlPublisher.agentAdded(str(this.agentCount), agent.props)
            return this.agentCount

        public void removeAgent(id)
            del this.agents[id]
            # if (len(this.agents) == 0
                # this.renderPiavca = false
            this.rlPublisher.agentRemoved(str(id))
            
        public void renderAgents()
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "render")
                    gl.glPushName (int(id))
                    agent.render()
                    gl.glPopName ()
            
            objectsToTest = dict(filter(lambda item hasattr(item[1], "agentCollisionTest") and item[1].agentCollisionTest==true, this.objects.iteritems()))
            agentsToTest = dict(filter(lambda item hasattr(item[1], "collisionTest") and item[1].collisionTest==true, this.agents.iteritems()))
            collisions = this.agentHitTest(agentsToTest, objectsToTest)       
                            
            for pair in collisions                 
                agentObjectCollision(pair[0], pair[1], this.app)

        public void agentActionStarted(callback, unique_actionid, agentId, action, details)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionStarted " + str(action) + " " + str(callback))
            if (hasattr("agentPublisher")
                this.agentPublisher.agentActionStarted(agentId, action, details)

            this.agentActions[unique_actionid] = agents.EchoesAgent.AgentAction(callback, agentId, action, details)
            this.actionLock.release()
            
        public void agentActionCompleted(unique_actionid, success=true)
            this.actionLock.acquire()
            # pass
            Logger.trace("info",  "agentActionCompleted (" + str(unique_actionid) + ") " + str(success))
            if (hasattr("agentPublisher") and unique_actionid in this.agentActions
                # if (this.agentActions[unique_actionid].callback
                    # Logger.trace("info",  "calling ice_response on callback " + str(this.agentActions[unique_actionid].callback)) 
                    # this.agentActions[unique_actionid].callback.ice_response(success)
                try
                    if (success
                        this.agentPublisher.agentActionCompleted(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details)
                    else
                        this.agentPublisher.agentActionFailed(this.agentActions[unique_actionid].agentId, this.agentActions[unique_actionid].action, this.agentActions[unique_actionid].details, "Probably a combined action failed, because the object was moved while the agent was walking there")
                except
                    Logger.warning("Incomplete information in completed agent action")
                del this.agentActions[unique_actionid]
            else
                Logger.warning("Agent action completed was called with non-existing id " + str(unique_actionid))
            this.actionLock.release()
                    
        public void getObjectIds()
            return this.objects.keys()
                
        public void getObjectAtPosition(x, y)
            Logger.trace("info",  "Looking for objects at " + str(x) + "," + str(y))

            # Based on code from http//nehe.gamedev.net/data/lessons/lesson.asp?lesson=32
            
            # Get the current viewport
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            
            # Prepare a buffer to hold the results
            gl.glSelectBuffer (100)

            # Put OpenGL into selection mode, and reset the name stack
            gl.glRenderMode(GL2.GL_SELECT)
            gl.glInitNames()
            
            # Only draw in the area under the mouse click
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPushMatrix()
            gl.glLoadIdentity()
            gl.gluPickMatrix(x, viewport[3] - y, 1.0, 1.0, viewport)
            
            # Multiply the perspective matrix by the pick matrix to restrict the drawing area
            this.projection()
            
            # Switch to normal mode, render the target to the buffer, and do some further mapping
            gl.glMatrixMode(GL2.GL_MODELVIEW)
            this.renderObjects(true)
            gl.glMatrixMode(GL2.GL_PROJECTION)
            gl.glPopMatrix()
            gl.glMatrixMode(GL2.GL_MODELVIEW)

            # Switch back to normal mode and see whether we hit anything
            records = glRenderMode(GL2.GL_RENDER)
            hitObject = -1
            # Changed mode always take the "top" object instead of the "nearest" one (unless it's the shed)
#            if (len(records) > 0
#                hitObject = records[len(records)-1].names[0]
#                if (this.objects[hitObject].props['type'] == "Shed" and len(records) > 1
#                    hitObject = records[len(records)-2].names[0]
            distance = 1000
            for record in records
                if ((record.near < distance)
                    distance = record.near
                    hitObject = record.names[0]
                    
            return hitObject
        
        public void getAgentAtPosition(x, y)
            Logger.trace("info",  "Looking for agents at " + str(x) + "," + str(y))
            rx, ry, rz = this.getWorldCoord((x,y))
            for id in this.agents.keys()
                agent = this.agents[id]
                if (hasattr(agent, "avatar")
                    c = agent.getXYContour()
                    if (c[0][0] < rx and c[2][0] > rx and c[0][1] < ry and c[1][1] > ry
                        return id 
            return -1

        public void getScreenCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)
            # not sure the y value is correct here... look below
            return gluProject(pos[0], pos[1], pos[2], model, projection, viewport)
                    
        public void getWorldCoord(pos)
            model = glGetDoublev(GL2.GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL2.GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL2.GL_VIEWPORT)            
            wz = glReadPixels(pos[0],pos[0],1,1,GL2.GL_DEPTH_COMPONENT,GL2.GL_FLOAT)[0][0]
            unprojected = gluUnProject(pos[0], viewport[3]-pos[1], wz, model, projection, viewport)
            return unprojected

        public void drawBezier(ctrlPoints, drawPoints=false, numStrips=30.0)
            gl.glMap1f(GL2.GL_MAP1_VERTEX_3, 0.0, 1.0, ctrlPoints)
            gl.glEnable(GL2.GL_MAP1_VERTEX_3)
            gl.glBegin(GL2.GL_LINE_STRIP)
            for i in range(0,int(numStrips))
                gl.glEvalCoord1f(i/float(numStrips))
            gl.glEnd()
            if (drawPoints
                gl.glPointSize(5.0)
                gl.glColor3f(1.0, 1.0, 0.0)
                gl.glBegin(GL2.GL_POINTS)
                for point in ctrlPoints 
                    gl.glVertex3fv(point)
                gl.glEnd()
                
                
        public void hitTest(things, otherThings=None)
            collisions = []
            if (not otherThings
                for id1 in things.keys()
                    for id2 in things.keys()
                        if ((id2 < id1)
                            continue
                        if ((id1 != id2)
                            o1 = things[id1]
                            o2 = things[id2]
                            deltaX = o2.pos[0] - o1.pos[0]
                            deltaY = o2.pos[1] - o1.pos[1]
                            deltaZ = o2.pos[2] - o1.pos[2]
                            if (isinstance(o1, objects.Plants.EchoesFlower) or isinstance(o2, objects.Plants.EchoesFlower)
                                if (isinstance(o1, objects.Plants.EchoesFlower)
                                    flower = o1
                                    other = o2
                                else
                                    flower = o2
                                    other = o1
                                deltaY = flower.pos[1] - other.pos[1]
                                if ((abs(deltaX) <= other.size and 
                                    deltaY < (other.size + flower.stemLength) and deltaY > 0)
                                    collisions.append([o1, o2])                                    
                            else
                                distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                                minDistance = o1.size + o2.size
                                if ((distanceSquared < minDistance * minDistance)
                                    collisions.append([o1,o2])
            else
                for o1 in things
                    for o2 in otherThings
                        deltaX = o2.pos[0] - o1.pos[0]
                        deltaY = o2.pos[1] - o1.pos[1]
                        deltaZ = o2.pos[2] - o1.pos[2]
                        distanceSquared = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ
                        minDistance = o1.size + o2.size
                        if ((distanceSquared < minDistance * minDistance)
                            collisions.append([o1,o2])
                
            return collisions
        
        
        public void agentHitTest(agentsToTest, objectsToTest)
            noAvatars = dict()
            collisions = []
            for aid, agent in agentsToTest.items()
                if (isinstance(agent, agents.PiavcaAvatars.EchoesAvatar)
                    bb = agent.getXYContour()
                    for oid, object in objectsToTest.items()
                        if (object.pos[0] > bb[0][0] and object.pos[0] < bb[2][0] and object.pos[1] > bb[0][1] and object.pos[1] < bb[1][1]
                            if (object.beingDragged object.draggedOverAgent = agent.id
                            else object.draggedOverAgent = None
                            object.overAgent = agent.id
                            collisions.append([agent, object])
                        else
                            object.draggedOverAgent = None
                            object.overAgent = None                            
                else
                    noAvatars[aid] = agent
            if (len(noAvatars) > 0
                collisions += this.hitTest(noAvatars, objectsToTest)
            return collisions                              
        
        public void saveScreenshot(name=None, path=None)
            """ Read in the screen information in the area specified """
            gl.glFinish()
            gl.glPixelStorei(GL2.GL_PACK_ALIGNMENT, 4)
            gl.glPixelStorei(GL2.GL_PACK_ROW_LENGTH, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_ROWS, 0)
            gl.glPixelStorei(GL2.GL_PACK_SKIP_PIXELS, 0)

            data = glReadPixels(0, 0, this.size[0], this.size[1], GL2.GL_RGBA, GL2.GL_UNSIGNED_BYTE)
            
            if (not name
                name = datetime.datetime.now().strftime("%Y-%m-%d_%H.%M")
            if (not path
                path = os.getcwd()

            im = PIL.Image.fromstring("RGBA", this.size, data)
            im.rotate(180).transpose(PIL.Image.FLIP_LEFT_RIGHT).save(path + "/" + name + ".png","PNG")

}
        
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:434)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
